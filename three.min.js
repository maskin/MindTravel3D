/**
 * Minimal Three.js Implementation for MindTravel3D
 * Compatible with official Three.js API structure
 * Version: Custom r170-compatible
 */

(function(global) {
    'use strict';

    // Core Three.js namespace
    var THREE = {};
    
    // Version info
    THREE.REVISION = '170';
    
    // Math utilities
    THREE.MathUtils = {
        generateUUID: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    // Vector2 class
    THREE.Vector2 = function(x, y) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
    };

    THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        
        set: function(x, y) {
            this.x = x; this.y = y;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y;
            return this;
        }
    };

    // Vector3 class
    THREE.Vector3 = function(x, y, z) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
        this.z = z !== undefined ? z : 0;
    };

    THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        
        set: function(x, y, z) {
            this.x = x; this.y = y; this.z = z;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y; this.z = v.z;
            return this;
        },
        
        add: function(v) {
            this.x += v.x; this.y += v.y; this.z += v.z;
            return this;
        },
        
        normalize: function() {
            var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (length > 0) {
                this.x /= length; this.y /= length; this.z /= length;
            }
            return this;
        }
    };

    // Color class
    THREE.Color = function(r, g, b) {
        this.r = r !== undefined ? r : 1;
        this.g = g !== undefined ? g : 1;
        this.b = b !== undefined ? b : 1;
    };

    THREE.Color.prototype = {
        constructor: THREE.Color,
        
        setHex: function(hex) {
            this.r = ((hex >> 16) & 255) / 255;
            this.g = ((hex >> 8) & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        }
    };

    // Scene class
    THREE.Scene = function() {
        this.type = 'Scene';
        this.children = [];
        this.background = null;
    };

    THREE.Scene.prototype = {
        constructor: THREE.Scene,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Fog class
    THREE.Fog = function(color, near, far) {
        this.name = '';
        this.color = new THREE.Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
    };

    // Camera base class
    THREE.Camera = function() {
        this.type = 'Camera';
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.matrixWorldInverse = new THREE.Matrix4();
        this.projectionMatrix = new THREE.Matrix4();
    };

    // PerspectiveCamera
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
        THREE.Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.updateProjectionMatrix();
    };

    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Simplified projection matrix calculation
        this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simple lookAt implementation - in a real implementation this would
        // calculate the proper rotation matrix
        if (typeof x === 'object') {
            // Vector3 passed
            this.lookAtVector = x;
        } else {
            // x, y, z coordinates passed
            this.lookAtVector = new THREE.Vector3(x, y, z);
        }
    };

    // Matrix4 class (simplified)
    THREE.Matrix4 = function() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    };

    // WebGL Renderer (simplified with 2D fallback)
    THREE.WebGLRenderer = function(parameters) {
        parameters = parameters || {};
        
        this.domElement = parameters.canvas || document.createElement('canvas');
        
        // Try to get WebGL context first
        this.context = null;
        try {
            this.context = this.domElement.getContext('webgl', parameters) || 
                          this.domElement.getContext('experimental-webgl', parameters);
        } catch (e) {
            console.warn('WebGL not available, falling back to 2D context');
        }
        
        // Fallback to 2D context if WebGL is not available
        if (!this.context) {
            console.log('WebGLRenderer initialized with 2D fallback');
            this.context = this.domElement.getContext('2d');
            this.is2DFallback = true;
        } else {
            console.log('WebGLRenderer initialized with WebGL context');
            this.is2DFallback = false;
        }
        
        this.shadowMap = {
            enabled: false,
            type: THREE.PCFShadowMap
        };
        
        this.outputColorSpace = THREE.SRGBColorSpace;
        this.clearColor = { r: 0, g: 0, b: 0 };
        this.fog = false;
    };

    THREE.WebGLRenderer.prototype = {
        constructor: THREE.WebGLRenderer,
        
        setSize: function(width, height, updateStyle) {
            this.domElement.width = width;
            this.domElement.height = height;
            
            if (updateStyle !== false) {
                this.domElement.style.width = width + 'px';
                this.domElement.style.height = height + 'px';
            }
            
            if (this.context) {
                this.context.viewport(0, 0, width, height);
            }
        },
        
        render: function(scene, camera) {
            if (!this.context) return;
            
            if (this.is2DFallback) {
                // 2D Canvas rendering fallback
                var ctx = this.context;
                var width = this.domElement.width;
                var height = this.domElement.height;
                
                // Clear canvas with background color
                ctx.fillStyle = 'rgb(' + 
                    Math.floor(this.clearColor.r * 255) + ',' +
                    Math.floor(this.clearColor.g * 255) + ',' +
                    Math.floor(this.clearColor.b * 255) + ')';
                ctx.fillRect(0, 0, width, height);
                
                // Simple 2D representation of 3D scene
                // This is a basic fallback - just render a simple representation
                ctx.fillStyle = '#333333';
                ctx.fillRect(width/4, height/4, width/2, height/2);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('3D Maze Game', width/2, height/2);
                ctx.fillText('WebGL not available - using 2D fallback', width/2, height/2 + 20);
            } else {
                // WebGL rendering
                this.context.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, 1.0);
                this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
                
                // Simple rendering - just clear for now
                // Real implementation would render all scene objects
            }
        },
        
        setClearColor: function(color, alpha) {
            if (typeof color === 'number') {
                // Convert hex color to RGB
                this.clearColor = {
                    r: ((color >> 16) & 255) / 255,
                    g: ((color >> 8) & 255) / 255,
                    b: (color & 255) / 255
                };
            } else if (color && typeof color === 'object') {
                this.clearColor = {
                    r: color.r || 0,
                    g: color.g || 0,
                    b: color.b || 0
                };
            }
        },
        
        setPixelRatio: function(value) {
            // Set pixel ratio
        },
        
        dispose: function() {
            // Cleanup
        }
    };

    // Geometry classes
    THREE.BufferGeometry = function() {
        this.type = 'BufferGeometry';
        this.attributes = {};
        this.isBufferGeometry = true;
    };

    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            depth: depth || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1,
            depthSegments: depthSegments || 1
        };
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1
        };
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'CylinderGeometry';
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius || 1,
            widthSegments: widthSegments || 32,
            heightSegments: heightSegments || 16,
            phiStart: phiStart || 0,
            phiLength: phiLength || Math.PI * 2,
            thetaStart: thetaStart || 0,
            thetaLength: thetaLength || Math.PI
        };
        
        // Simple sphere geometry data
        this.vertices = [];
        this.faces = [];
        this.uvs = [];
        
        // Generate sphere vertices using spherical coordinates
        var r = this.parameters.radius;
        var widthSegs = Math.max(3, this.parameters.widthSegments);
        var heightSegs = Math.max(2, this.parameters.heightSegments);
        
        for (var y = 0; y <= heightSegs; y++) {
            var v = y / heightSegs;
            var theta = v * Math.PI;
            
            for (var x = 0; x <= widthSegs; x++) {
                var u = x / widthSegs;
                var phi = u * Math.PI * 2;
                
                var px = -r * Math.cos(phi) * Math.sin(theta);
                var py = r * Math.cos(theta);
                var pz = r * Math.sin(phi) * Math.sin(theta);
                
                this.vertices.push(px, py, pz);
            }
        }
        
        // Generate faces
        for (var y = 0; y < heightSegs; y++) {
            for (var x = 0; x < widthSegs; x++) {
                var v1 = (widthSegs + 1) * y + x;
                var v2 = (widthSegs + 1) * y + x + 1;
                var v3 = (widthSegs + 1) * (y + 1) + x;
                var v4 = (widthSegs + 1) * (y + 1) + x + 1;
                
                if (y !== 0) {
                    this.faces.push(v1, v3, v2);
                }
                if (y !== heightSegs - 1) {
                    this.faces.push(v2, v3, v4);
                }
            }
        }
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

    // Material classes
    THREE.Material = function() {
        this.type = 'Material';
        this.color = new THREE.Color(0xffffff);
        this.transparent = false;
        this.opacity = 1;
    };

    THREE.MeshBasicMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshBasicMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

    THREE.MeshLambertMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshLambertMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
        if (parameters.map !== undefined) this.map = parameters.map;
        if (parameters.emissive !== undefined) this.emissive = new THREE.Color(parameters.emissive);
        
        // Default values
        this.emissive = this.emissive || new THREE.Color(0x000000);
        this.map = this.map || null;
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

    THREE.MeshPhongMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshPhongMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
        if (parameters.map !== undefined) this.map = parameters.map;
        if (parameters.emissive !== undefined) this.emissive = new THREE.Color(parameters.emissive);
        if (parameters.specular !== undefined) this.specular = new THREE.Color(parameters.specular);
        if (parameters.shininess !== undefined) this.shininess = parameters.shininess;
        
        // Default values
        this.emissive = this.emissive || new THREE.Color(0x000000);
        this.specular = this.specular || new THREE.Color(0x111111);
        this.shininess = this.shininess !== undefined ? this.shininess : 30;
        this.map = this.map || null;
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

    // Object3D base class
    THREE.Object3D = function() {
        this.uuid = THREE.MathUtils.generateUUID();
        this.type = 'Object3D';
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.parent = null;
        this.children = [];
    };

    THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        
        add: function(object) {
            if (object === this) {
                console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                return this;
            }
            
            this.children.push(object);
            object.parent = this;
            return this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
            return this;
        },
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].traverse(callback);
            }
        }
    };

    // Mesh class
    THREE.Mesh = function(geometry, material) {
        THREE.Object3D.call(this);
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.constructor = THREE.Mesh;

    // Light classes
    THREE.Light = function(color, intensity) {
        THREE.Object3D.call(this);
        this.type = 'Light';
        this.color = new THREE.Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.constructor = THREE.Light;

    THREE.AmbientLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

    THREE.DirectionalLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.target = { position: new THREE.Vector3() };
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500,
                left: -5,
                right: 5,
                top: 5,
                bottom: -5
            }
        };
        this.castShadow = false;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

    THREE.SpotLight = function(color, intensity, distance, angle, penumbra, decay) {
        THREE.Light.call(this, color, intensity);
        this.type = 'SpotLight';
        this.distance = distance !== undefined ? distance : 0;
        this.angle = angle !== undefined ? angle : Math.PI / 3;
        this.penumbra = penumbra !== undefined ? penumbra : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.target = { 
            position: new THREE.Vector3(),
            updateMatrixWorld: function() {}
        };
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500
            }
        };
        this.castShadow = false;
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.constructor = THREE.SpotLight;

    THREE.PointLight = function(color, intensity, distance, decay) {
        THREE.Light.call(this, color, intensity);
        this.type = 'PointLight';
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500
            }
        };
        this.castShadow = false;
    };  
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;

    // Texture classes
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.image = image;
        this.needsUpdate = false;
        this.colorSpace = THREE.SRGBColorSpace;
        this.wrapS = wrapS || THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT || THREE.ClampToEdgeWrapping;
    };

    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

    THREE.TextureLoader = function() {};
    THREE.TextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var image = new Image();
        image.onload = function() {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        };
        image.onerror = onError;
        image.src = url;
        return texture;
    };

    // CanvasTexture class
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.isTexture = true;
        this.uuid = THREE.MathUtils.generateUUID();
        this.image = canvas;
        this.mapping = mapping || THREE.UVMapping;
        this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipmapLinearFilter;
        this.format = format !== undefined ? format : THREE.RGBAFormat;
        this.type = type !== undefined ? type : THREE.UnsignedByteType;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.flipY = false;
        this.needsUpdate = true;
        this.repeat = new THREE.Vector2(1, 1);
        this.offset = new THREE.Vector2(0, 0);
    };

    THREE.CanvasTexture.prototype = {
        constructor: THREE.CanvasTexture,
        
        dispose: function() {
            // Cleanup logic
        }
    };

    // RingGeometry class
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius || 0.5,
            outerRadius: outerRadius || 1,
            thetaSegments: thetaSegments || 8,
            phiSegments: phiSegments || 1,
            thetaStart: thetaStart || 0,
            thetaLength: thetaLength || Math.PI * 2
        };
        
        // Simple ring geometry data
        this.vertices = [];
        this.faces = [];
        this.uvs = [];
        
        // Generate ring vertices
        var innerR = this.parameters.innerRadius;
        var outerR = this.parameters.outerRadius;
        var segments = this.parameters.thetaSegments;
        
        for (var i = 0; i <= segments; i++) {
            var angle = (i / segments) * Math.PI * 2;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            
            // Inner vertex
            this.vertices.push(innerR * cos, 0, innerR * sin);
            // Outer vertex
            this.vertices.push(outerR * cos, 0, outerR * sin);
        }
    };

    THREE.RingGeometry.prototype = {
        constructor: THREE.RingGeometry
    };

    // Constants
    THREE.SRGBColorSpace = 'srgb';
    THREE.LinearSRGBColorSpace = 'srgb-linear';
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.BasicShadowMap = 0;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.RepeatWrapping = 1000;
    THREE.LinearFilter = 1006;
    THREE.LinearMipmapLinearFilter = 1008;
    THREE.RGBAFormat = 1023;
    THREE.UnsignedByteType = 1009;
    THREE.UVMapping = 300;
    THREE.sRGBEncoding = 3001;

    // Group class
    THREE.Group = function() {
        this.type = 'Group';
        this.children = [];
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
    };

    THREE.Group.prototype = {
        constructor: THREE.Group,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        }
    };

    // Export THREE to global scope
    global.THREE = THREE;
    
    console.log('Three.js Custom Implementation r170 loaded successfully');

})(typeof window !== 'undefined' ? window : this);