// Complete Three.js-compatible implementation for 3D maze rendering
(function() {
    'use strict';
    
    // Global canvas context for 2D fallback rendering
    let globalCanvas = null;
    let globalCtx = null;
    
    // Basic 3D math utilities
    function Vector3(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    Vector3.prototype.set = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    
    Vector3.prototype.copy = function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    
    // Object3D base class
    function Object3D() {
        this.position = new Vector3();
        this.rotation = new Vector3();
        this.scale = new Vector3(1, 1, 1);
        this.children = [];
        this.parent = null;
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Object3D.prototype.add = function(object) {
        this.children.push(object);
        object.parent = this;
    };
    
    Object3D.prototype.remove = function(object) {
        const index = this.children.indexOf(object);
        if (index > -1) {
            this.children.splice(index, 1);
            object.parent = null;
        }
    };
    
    Object3D.prototype.traverse = function(callback) {
        callback(this);
        for (let child of this.children) {
            if (child.traverse) {
                child.traverse(callback);
            } else {
                callback(child);
            }
        }
    };
    
    Object3D.prototype.updateMatrixWorld = function() {
        // Basic matrix update implementation (placeholder)
        // For simplicity, we just update the matrix based on position, rotation, scale
        if (this.parent) {
            // In a full implementation, this would multiply with parent matrix
        }
    };
    
    // Scene class
    function Scene() {
        Object3D.call(this);
        this.fog = null;
        this.background = null;
    }
    Scene.prototype = Object.create(Object3D.prototype);
    Scene.prototype.constructor = Scene;
    
    // Camera class
    function PerspectiveCamera(fov = 50, aspect = 1, near = 0.1, far = 2000) {
        Object3D.call(this);
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.zoom = 1;
    }
    PerspectiveCamera.prototype = Object.create(Object3D.prototype);
    PerspectiveCamera.prototype.constructor = PerspectiveCamera;
    
    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Update projection matrix (placeholder)
    };
    
    PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simple lookAt implementation
        // For now, just store the target position
        if (typeof x === 'object') {
            this.target = { x: x.x, y: x.y, z: x.z };
        } else {
            this.target = { x: x, y: y, z: z };
        }
    };
    
    // Material classes
    function Material() {
        this.color = { r: 1, g: 1, b: 1 };
        this.transparent = false;
        this.opacity = 1;
        this.wireframe = false;
    }
    
    function MeshLambertMaterial(params = {}) {
        Material.call(this);
        if (params.color !== undefined) {
            this.color = this.parseColor(params.color);
        }
        if (params.transparent !== undefined) {
            this.transparent = params.transparent;
        }
        if (params.wireframe !== undefined) {
            this.wireframe = params.wireframe;
        }
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    
    MeshLambertMaterial.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 1, g: 1, b: 1 };
    };
    
    // Geometry classes
    function Geometry() {
        this.vertices = [];
        this.faces = [];
    }
    
    function BoxGeometry(width = 1, height = 1, depth = 1) {
        Geometry.call(this);
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.generateBox();
    }
    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;
    
    BoxGeometry.prototype.generateBox = function() {
        const w = this.width / 2;
        const h = this.height / 2;
        const d = this.depth / 2;
        
        // Box vertices
        this.vertices = [
            [-w, -h, -d], [w, -h, -d], [w, h, -d], [-w, h, -d],  // front
            [-w, -h, d], [w, -h, d], [w, h, d], [-w, h, d]       // back
        ];
        
        // Box faces (simplified)
        this.faces = [
            [0, 1, 2, 3], // front
            [4, 7, 6, 5], // back
            [0, 4, 5, 1], // bottom
            [2, 6, 7, 3], // top
            [0, 3, 7, 4], // left
            [1, 5, 6, 2]  // right
        ];
    };
    
    function PlaneGeometry(width = 1, height = 1) {
        Geometry.call(this);
        this.width = width;
        this.height = height;
        this.generatePlane();
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    
    PlaneGeometry.prototype.generatePlane = function() {
        const w = this.width / 2;
        const h = this.height / 2;
        
        this.vertices = [
            [-w, 0, -h], [w, 0, -h], [w, 0, h], [-w, 0, h]
        ];
        
        this.faces = [[0, 1, 2, 3]];
    };
    
    function CylinderGeometry(radiusTop = 1, radiusBottom = 1, height = 1) {
        Geometry.call(this);
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.generateCylinder();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    
    CylinderGeometry.prototype.generateCylinder = function() {
        // Simplified cylinder as octagon
        const segments = 8;
        const h = this.height / 2;
        const r = this.radiusBottom;
        
        this.vertices = [];
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            this.vertices.push([x, -h, z], [x, h, z]);
        }
        
        this.faces = [];
        for (let i = 0; i < segments; i++) {
            const next = (i + 1) % segments;
            this.faces.push([i*2, next*2, next*2+1, i*2+1]);
        }
    };
    
    // Mesh class
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.geometry = geometry;
        this.material = material;
    }
    Mesh.prototype = Object.create(Object3D.prototype);
    Mesh.prototype.constructor = Mesh;
    
    // Light classes
    function Light(color = 0xffffff, intensity = 1) {
        Object3D.call(this);
        this.color = this.parseColor(color);
        this.intensity = intensity;
    }
    Light.prototype = Object.create(Object3D.prototype);
    Light.prototype.constructor = Light;
    
    Light.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 1, g: 1, b: 1 };
    };
    
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
    }
    AmbientLight.prototype = Object.create(Light.prototype);
    AmbientLight.prototype.constructor = AmbientLight;
    
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.target = new Object3D();
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: { near: 0.5, far: 500 }
        };
    }
    DirectionalLight.prototype = Object.create(Light.prototype);
    DirectionalLight.prototype.constructor = DirectionalLight;
    
    function SpotLight(color, intensity, distance, angle, penumbra) {
        Light.call(this, color, intensity);
        this.distance = distance || 0;
        this.angle = angle || Math.PI / 3;
        this.penumbra = penumbra || 0;
        this.target = new Object3D();
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: { near: 0.5, far: 500 }
        };
    }
    SpotLight.prototype = Object.create(Light.prototype);
    SpotLight.prototype.constructor = SpotLight;
    
    function PointLight(color, intensity, distance) {
        Light.call(this, color, intensity);
        this.distance = distance || 0;
    }
    PointLight.prototype = Object.create(Light.prototype);
    PointLight.prototype.constructor = PointLight;
    
    // Fog class
    function Fog(color, near, far) {
        this.color = this.parseColor(color);
        this.near = near || 1;
        this.far = far || 1000;
    }
    
    Fog.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 0, g: 0, b: 0 };
    };
    
    // WebGL Renderer with 2D Canvas fallback
    function WebGLRenderer(params = {}) {
        this.domElement = params.canvas || document.createElement('canvas');
        this.context = null;
        this.shadowMap = { enabled: false, type: 'PCFSoftShadowMap' };
        this.fog = false;
        this.clearColor = { r: 0, g: 0, b: 0 };
        
        // Initialize 2D context for fallback rendering
        if (this.domElement) {
            globalCanvas = this.domElement;
            globalCtx = this.domElement.getContext('2d');
            this.context = globalCtx;
        }
        
        console.log('WebGLRenderer initialized with 2D fallback');
    }
    
    WebGLRenderer.prototype.setSize = function(width, height) {
        if (this.domElement) {
            this.domElement.width = width;
            this.domElement.height = height;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
        }
    };
    
    WebGLRenderer.prototype.setPixelRatio = function(ratio) {
        // Placeholder
    };
    
    WebGLRenderer.prototype.setClearColor = function(color) {
        if (typeof color === 'number') {
            this.clearColor = {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
    };
    
    WebGLRenderer.prototype.render = function(scene, camera) {
        if (!this.context || !globalCanvas) return;
        
        const ctx = this.context;
        const canvas = globalCanvas;
        
        // Clear canvas with black background
        ctx.fillStyle = `rgb(${this.clearColor.r * 255}, ${this.clearColor.g * 255}, ${this.clearColor.b * 255})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Simple 3D to 2D projection rendering
        this.renderScene(scene, camera, ctx, canvas);
    };
    
    WebGLRenderer.prototype.renderScene = function(scene, camera, ctx, canvas) {
        const cameraX = camera.position.x;
        const cameraZ = camera.position.z;
        const cameraY = camera.position.y;
        const cameraRotY = camera.rotation.y;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 100; // Projection scale
        
        let wallCount = 0;
        let floorCount = 0;
        
        // Render all objects in scene
        this.traverseAndRender(scene, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, {wallCount: 0, floorCount: 0});
        
        // Draw debug info
        ctx.fillStyle = '#00ff00';
        ctx.font = '14px Arial';
        ctx.fillText(`Camera: ${cameraX.toFixed(1)}, ${cameraY.toFixed(1)}, ${cameraZ.toFixed(1)}`, 10, canvas.height - 60);
        ctx.fillText(`Canvas: ${canvas.width}x${canvas.height}`, 10, canvas.height - 40);
        ctx.fillText('RENDERER ACTIVE', 10, canvas.height - 20);
    };
    
    WebGLRenderer.prototype.traverseAndRender = function(object, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters) {
        if (!object.visible) return;
        
        if (object.geometry && object.material) {
            this.renderMesh(object, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters);
        }
        
        // Render children
        for (let child of object.children) {
            this.traverseAndRender(child, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters);
        }
    };
    
    WebGLRenderer.prototype.renderMesh = function(mesh, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters) {
        const objX = mesh.position.x;
        const objY = mesh.position.y;
        const objZ = mesh.position.z;
        
        // Simple distance culling
        const dx = objX - cameraX;
        const dz = objZ - cameraZ;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 15) return; // Don't render distant objects
        
        // Rotate relative to camera
        const cos = Math.cos(-cameraRotY);
        const sin = Math.sin(-cameraRotY);
        const rotX = dx * cos - dz * sin;
        const rotZ = dx * sin + dz * cos;
        
        // Skip objects behind camera
        if (rotZ <= 0.1) return;
        
        // Project to screen
        const screenX = centerX + (rotX / rotZ) * scale;
        const screenY = centerY - ((objY - cameraY) / rotZ) * scale;
        const size = scale / rotZ;
        
        // Skip objects outside screen
        if (screenX < -100 || screenX > centerX * 2 + 100 || 
            screenY < -100 || screenY > centerY * 2 + 100) return;
        
        // Determine color from material
        let color = '#888888'; // Default gray
        if (mesh.material && mesh.material.color) {
            const c = mesh.material.color;
            color = `rgb(${Math.floor(c.r * 255)}, ${Math.floor(c.g * 255)}, ${Math.floor(c.b * 255)})`;
        }
        
        // Render based on geometry type
        if (mesh.geometry.constructor.name === 'BoxGeometry') {
            // Render as rectangle (wall)
            const width = size * mesh.geometry.width;
            const height = size * mesh.geometry.height;
            
            ctx.fillStyle = color;
            ctx.fillRect(screenX - width/2, screenY - height/2, width, height);
            
            // Add wireframe for visibility
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(screenX - width/2, screenY - height/2, width, height);
            
            counters.wallCount++;
            
        } else if (mesh.geometry.constructor.name === 'PlaneGeometry') {
            // Render as small rectangle (floor)
            const tileSize = size * 0.8;
            
            ctx.fillStyle = color;
            ctx.fillRect(screenX - tileSize/2, screenY - tileSize/2, tileSize, tileSize);
            
            counters.floorCount++;
            
        } else if (mesh.geometry.constructor.name === 'CylinderGeometry') {
            // Render as circle (goal)
            const radius = size * mesh.geometry.radiusBottom;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Glow effect for goal
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(screenX, screenY, radius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    };
    
    // Texture classes (basic implementations for compatibility)
    function Texture() {
        this.wrapS = 'clamp-to-edge';
        this.wrapT = 'clamp-to-edge';
        this.repeat = { x: 1, y: 1 };
        this.needsUpdate = true;
    }
    
    Texture.prototype.set = function(x, y) {
        this.repeat.x = x;
        this.repeat.y = y;
    };
    
    function CanvasTexture(canvas) {
        // Call parent constructor
        Texture.call(this);
        
        // Set properties
        this.image = canvas;
        this.canvas = canvas;
        this.isCanvasTexture = true;
        this.needsUpdate = true;
        
        console.log('CanvasTexture created successfully for canvas:', canvas);
        return this;
    }
    
    // Proper prototype inheritance
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    
    // Add any specific methods for CanvasTexture
    CanvasTexture.prototype.dispose = function() {
        this.image = null;
        this.canvas = null;
    };
    
    // Texture wrapping constants
    const RepeatWrapping = 'repeat';
    const ClampToEdgeWrapping = 'clamp-to-edge';
    
    // Constants
    const PCFSoftShadowMap = 'PCFSoftShadowMap';
    
    // Export the THREE object
    window.THREE = {
        Scene: Scene,
        PerspectiveCamera: PerspectiveCamera,
        WebGLRenderer: WebGLRenderer,
        BoxGeometry: BoxGeometry,
        PlaneGeometry: PlaneGeometry,
        CylinderGeometry: CylinderGeometry,
        MeshLambertMaterial: MeshLambertMaterial,
        Mesh: Mesh,
        AmbientLight: AmbientLight,
        DirectionalLight: DirectionalLight,
        SpotLight: SpotLight,
        PointLight: PointLight,
        Fog: Fog,
        Vector3: Vector3,
        Object3D: Object3D,
        Texture: Texture,
        CanvasTexture: CanvasTexture,
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        PCFSoftShadowMap: PCFSoftShadowMap
    };
    
    console.log('THREE.js compatible library loaded with 2D fallback renderer');
})();
