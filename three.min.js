/**
 * Minimal Three.js Implementation for MindTravel3D
 * Compatible with official Three.js API structure
 * Version: Custom r170-compatible
 */

(function(global) {
    'use strict';

    // Core Three.js namespace
    var THREE = {};
    
    // Version info
    THREE.REVISION = '170';
    
    // Math utilities
    THREE.MathUtils = {
        generateUUID: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    // Vector2 class
    THREE.Vector2 = function(x, y) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
    };

    THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        
        set: function(x, y) {
            this.x = x; this.y = y;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y;
            return this;
        }
    };

    // Vector3 class
    THREE.Vector3 = function(x, y, z) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
        this.z = z !== undefined ? z : 0;
    };

    THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        
        set: function(x, y, z) {
            this.x = x; this.y = y; this.z = z;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y; this.z = v.z;
            return this;
        },
        
        add: function(v) {
            this.x += v.x; this.y += v.y; this.z += v.z;
            return this;
        },
        
        normalize: function() {
            var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (length > 0) {
                this.x /= length; this.y /= length; this.z /= length;
            }
            return this;
        }
    };

    // Color class
    THREE.Color = function(r, g, b) {
        this.r = r !== undefined ? r : 1;
        this.g = g !== undefined ? g : 1;
        this.b = b !== undefined ? b : 1;
    };

    THREE.Color.prototype = {
        constructor: THREE.Color,
        
        setHex: function(hex) {
            this.r = ((hex >> 16) & 255) / 255;
            this.g = ((hex >> 8) & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        }
    };

    // Scene class
    THREE.Scene = function() {
        this.type = 'Scene';
        this.children = [];
        this.background = null;
    };

    THREE.Scene.prototype = {
        constructor: THREE.Scene,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            // Call callback on this object
            callback(this);
            
            // Recursively traverse all children
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Camera base class
    THREE.Camera = function() {
        this.type = 'Camera';
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.matrixWorldInverse = new THREE.Matrix4();
        this.projectionMatrix = new THREE.Matrix4();
    };

    // PerspectiveCamera
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
        THREE.Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.updateProjectionMatrix();
    };

    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Simplified projection matrix calculation
        this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simplified lookAt implementation
        if (typeof x === 'object') {
            // lookAt(vector)
            console.log('Camera lookAt vector:', x);
        } else {
            // lookAt(x, y, z)
            console.log('Camera lookAt coordinates:', x, y, z);
        }
        // In a real implementation, this would update the camera's rotation
        // For now, we'll just log the call
    };

    // Matrix4 class (simplified)
    THREE.Matrix4 = function() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    };

    // WebGL Renderer (simplified)
    THREE.WebGLRenderer = function(parameters) {
        parameters = parameters || {};
        
        this.domElement = parameters.canvas || document.createElement('canvas');
        this.context = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');
        
        this.shadowMap = {
            enabled: false,
            type: THREE.PCFShadowMap
        };
        
        this.outputColorSpace = THREE.SRGBColorSpace;
        
        // Add rendering state tracking
        this.renderCount = 0;
        this.lastLogTime = 0;
    };

    THREE.WebGLRenderer.prototype = {
        constructor: THREE.WebGLRenderer,
        
        setSize: function(width, height, updateStyle) {
            this.domElement.width = width;
            this.domElement.height = height;
            
            if (updateStyle !== false) {
                this.domElement.style.width = width + 'px';
                this.domElement.style.height = height + 'px';
            }
            
            if (this.context) {
                this.context.viewport(0, 0, width, height);
            }
        },
        
        render: function(scene, camera) {
            if (!this.context) return;
            
            var gl = this.context;
            this.renderCount++;
            var now = Date.now();
            
            // 3D„Éì„É•„Éº„ÅÆÊèèÁîª
            this.render3DView(scene, camera);
            
            // ‰øØÁû∞„Éì„É•„Éº„ÅÆÊèèÁîª
            this.renderTopDownView(scene, camera);
        },
        
        render3DView: function(scene, camera) {
            var gl = this.context;
            
            // Clear WebGL canvas with a visible color for 3D view
            gl.clearColor(0.1, 0.1, 0.3, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            
            // Á∞°Âçò„Å™3DËø∑Ë∑Ø„ÅÆÊèèÁîªÔºà„Ç≠„É•„Éº„Éñ„Éô„Éº„ÇπÔºâ
            this.draw3DMaze();
        },
        
        draw3DMaze: function() {
            // 3DÁ´ã‰ΩìËø∑Ë∑Ø„ÅÆÊèèÁîª„ÇíÂÆüË£Ö
            if (window.gameManager && window.gameManager.mazeGenerator && window.gameManager.mazeGenerator.maze) {
                var maze = window.gameManager.mazeGenerator.maze;
                var mazeWidth = window.gameManager.mazeGenerator.width;
                var mazeHeight = window.gameManager.mazeGenerator.height;
                
                // WebGL„ÅßÁ∞°Âçò„Å™3D„Ç≠„É•„Éº„Éñ„ÇíÊèèÁîªÔºàÊì¨‰ººÁöÑÔºâ
                var gl = this.context;
                
                // „Éó„É¨„Ç§„É§„ÉºË¶ñÁÇπ„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                // ÂÆüÈöõ„ÅÆ3DÊèèÁîª„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅË¶ñÁÇπ„Å´Âü∫„Å•„ÅÑ„Åü2DÊèèÁîª„ÇíË°å„ÅÜ
                var canvas3D = document.getElementById('gameCanvas3D');
                if (canvas3D) {
                    var ctx3D = canvas3D.getContext('2d');
                    if (ctx3D) {
                        this.drawPerspectiveView(ctx3D, canvas3D, maze, mazeWidth, mazeHeight);
                    }
                }
            }
        },
        
        drawPerspectiveView: function(ctx, canvas, maze, mazeWidth, mazeHeight) {
            // „Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ËÉåÊôØ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ÔºàÁ©∫Ôºâ
            var gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Á©∫Ëâ≤
            gradient.addColorStop(0.5, '#98D8E8');
            gradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„ÇíÂèñÂæó
            var playerX = 1.5;
            var playerZ = 1.5;
            var playerAngle = 0;
            
            if (window.gameManager && window.gameManager.gameEngine && window.gameManager.gameEngine.playerPosition) {
                playerX = window.gameManager.gameEngine.playerPosition.x;
                playerZ = window.gameManager.gameEngine.playerPosition.z;
                playerAngle = window.gameManager.gameEngine.playerRotation || 0;
            }
            
            // 3DÈ¢®„ÅÆÂ£Å„ÇíÊèèÁîª
            this.drawWallsInPerspective(ctx, canvas, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle);
            
            // „Éï„É¨„Éº„É†ÊÉÖÂ†±
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '16px Arial';
            ctx.fillText('3D View - First Person', 10, 30);
            ctx.font = '12px Arial';
            ctx.fillText('Player: (' + playerX.toFixed(1) + ', ' + playerZ.toFixed(1) + ')', 10, canvas.height - 20);
        },
        
        drawWallsInPerspective: function(ctx, canvas, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle) {
            var centerX = canvas.width / 2;
            var centerY = canvas.height / 2;
            var fov = Math.PI / 3; // 60Â∫¶„ÅÆË¶ñÈáéËßí
            var maxDistance = 8;
            
            // „É¨„Ç§„Ç≠„É£„Çπ„ÉÜ„Ç£„É≥„Ç∞È¢®„ÅÆÊèèÁîª
            for (var ray = 0; ray < canvas.width; ray += 2) {
                var rayAngle = playerAngle + (ray - centerX) * fov / canvas.width;
                var distance = this.castRay(maze, mazeWidth, mazeHeight, playerX, playerZ, rayAngle, maxDistance);
                
                if (distance < maxDistance) {
                    // Â£Å„ÅÆÈ´ò„Åï„ÇíË∑ùÈõ¢„Å´Âü∫„Å•„ÅÑ„Å¶Ë®àÁÆó
                    var wallHeight = (canvas.height * 0.6) / distance;
                    var wallTop = centerY - wallHeight / 2;
                    var wallBottom = centerY + wallHeight / 2;
                    
                    // Ë∑ùÈõ¢„Å´Âü∫„Å•„ÅèÊòéÂ∫¶
                    var brightness = Math.max(0.2, 1 - distance / maxDistance);
                    var wallColor = 'rgb(' + 
                        Math.floor(139 * brightness) + ',' +
                        Math.floor(69 * brightness) + ',' +
                        Math.floor(19 * brightness) + ')';
                    
                    ctx.fillStyle = wallColor;
                    ctx.fillRect(ray, wallTop, 2, wallBottom - wallTop);
                    
                    // Â∫ä
                    ctx.fillStyle = 'rgb(' + Math.floor(101 * brightness) + ',' + Math.floor(67 * brightness) + ',' + Math.floor(33 * brightness) + ')';
                    ctx.fillRect(ray, wallBottom, 2, canvas.height - wallBottom);
                }
            }
        },
        
        castRay: function(maze, mazeWidth, mazeHeight, startX, startZ, angle, maxDistance) {
            var dx = Math.cos(angle) * 0.1;
            var dz = Math.sin(angle) * 0.1;
            var x = startX;
            var z = startZ;
            var distance = 0;
            
            while (distance < maxDistance) {
                x += dx;
                z += dz;
                distance += 0.1;
                
                var mapX = Math.floor(x);
                var mapZ = Math.floor(z);
                
                if (mapX < 0 || mapX >= mazeWidth || mapZ < 0 || mapZ >= mazeHeight) {
                    return distance;
                }
                
                if (maze[mapZ] && maze[mapZ][mapX] === 1) {
                    return distance;
                }
            }
            
            return maxDistance;
        },
        
        renderTopDownView: function(scene, camera) {
            // ‰øØÁû∞„Éì„É•„Éº„ÅÆÊèèÁîª
            var topDownCanvas = document.getElementById('gameCanvasTopDown');
            if (!topDownCanvas) return;
            
            var ctx2d = topDownCanvas.getContext('2d');
            if (!ctx2d) return;
            
            try {
                // Clear canvas with dark background
                ctx2d.clearRect(0, 0, topDownCanvas.width, topDownCanvas.height);
                ctx2d.fillStyle = '#001122';
                ctx2d.fillRect(0, 0, topDownCanvas.width, topDownCanvas.height);
                
                // Draw actual maze data if available
                if (window.gameManager && window.gameManager.mazeGenerator && window.gameManager.mazeGenerator.maze) {
                    var maze = window.gameManager.mazeGenerator.maze;
                    var mazeWidth = window.gameManager.mazeGenerator.width;
                    var mazeHeight = window.gameManager.mazeGenerator.height;
                    
                    // Calculate scale to fit maze on screen
                    var scaleX = topDownCanvas.width / mazeWidth;
                    var scaleY = topDownCanvas.height / mazeHeight;
                    var scale = Math.min(scaleX, scaleY, 10); // Max cell size of 10 pixels
                    
                    // Center the maze
                    var offsetX = (topDownCanvas.width - mazeWidth * scale) / 2;
                    var offsetY = (topDownCanvas.height - mazeHeight * scale) / 2;
                    
                    // Draw maze walls
                    ctx2d.fillStyle = 'rgb(120, 80, 40)'; // Brown for walls
                    for (var y = 0; y < mazeHeight; y++) {
                        for (var x = 0; x < mazeWidth; x++) {
                            if (maze[y][x] === 1) { // Wall
                                ctx2d.fillRect(
                                    offsetX + x * scale,
                                    offsetY + y * scale,
                                    scale,
                                    scale
                                );
                            }
                        }
                    }
                    
                    // Draw goal position
                    var goalPos = window.gameManager.mazeGenerator.getGoalPosition();
                    ctx2d.fillStyle = 'rgb(0, 255, 0)'; // Green for goal
                    ctx2d.fillRect(
                        offsetX + goalPos.x * scale,
                        offsetY + goalPos.y * scale,
                        scale,
                        scale
                    );
                } else {
                    // Fallback: Draw simple placeholder walls
                    ctx2d.fillStyle = 'rgb(150, 100, 50)'; // Brown for walls
                    ctx2d.fillRect(50, 50, 100, 100);
                    ctx2d.fillRect(200, 100, 80, 120);
                    ctx2d.fillRect(350, 80, 60, 90);
                }
                
                // Draw player position indicator
                ctx2d.fillStyle = 'rgb(255, 255, 0)'; // Yellow for player
                if (window.gameManager && window.gameManager.gameEngine && window.gameManager.gameEngine.playerPosition && 
                    window.gameManager.mazeGenerator && window.gameManager.mazeGenerator.maze) {
                    // Use actual player position
                    var playerX = window.gameManager.gameEngine.playerPosition.x;
                    var playerZ = window.gameManager.gameEngine.playerPosition.z;
                    var screenX = offsetX + playerX * scale - scale/4;
                    var screenY = offsetY + playerZ * scale - scale/4;
                    ctx2d.fillRect(screenX, screenY, scale/2, scale/2);
                } else {
                    // Fallback: center position
                    ctx2d.fillRect(topDownCanvas.width/2 - 5, topDownCanvas.height/2 - 5, 10, 10);
                }
                
                // Draw text overlay
                ctx2d.fillStyle = 'white';
                ctx2d.font = '16px Arial';
                ctx2d.fillText('Top-Down View', 10, 30);
                ctx2d.fillText('Brown = Walls, Green = Goal, Yellow = Player', 10, topDownCanvas.height - 40);
                ctx2d.fillText('Use WASD or Arrow keys to move', 10, topDownCanvas.height - 20);
                
                // Update frame counter in UI instead of console logging
                var now = Date.now();
                if (this.renderCount % 60 === 0) {
                    // Update FPS display if available
                    var fpsElement = document.getElementById('fps');
                    if (fpsElement) {
                        var fps = Math.round(60000 / (now - this.lastLogTime || 1000));
                        fpsElement.textContent = fps;
                    }
                    this.lastLogTime = now;
                    
                    // Log occasionally for debugging
                    console.log('üé® Dual view rendering (frame ' + this.renderCount + ')');
                }
                
                // Show frame count in the canvas text
                ctx2d.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx2d.font = '12px Arial';
                ctx2d.fillText('Frame: ' + this.renderCount, topDownCanvas.width - 100, 20);
                
            } catch (renderError) {
                console.warn('‚ö†Ô∏è Dual view rendering failed:', renderError.message);
                // Clear canvas with error color
                ctx2d.fillStyle = '#800020';
                ctx2d.fillRect(0, 0, topDownCanvas.width, topDownCanvas.height);
                ctx2d.fillStyle = 'white';
                ctx2d.font = '16px Arial';
                ctx2d.fillText('Rendering Error', 10, topDownCanvas.height/2);
            }
        },
        
        clear: function() {
            if (!this.context) return;
            this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
        },
        
        getContext: function() {
            return this.context;
        },
        
        setClearColor: function(color, alpha) {
            // Set clear color
        },
        
        setPixelRatio: function(value) {
            // Set pixel ratio
        },
        
        dispose: function() {
            // Cleanup
        }
    };

    // Geometry classes
    THREE.BufferGeometry = function() {
        this.type = 'BufferGeometry';
        this.attributes = {};
        this.isBufferGeometry = true;
    };

    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            depth: depth || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1,
            depthSegments: depthSegments || 1
        };
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1
        };
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'CylinderGeometry';
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'SphereGeometry';
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

    // Material classes
    THREE.Material = function() {
        this.type = 'Material';
        this.color = new THREE.Color(0xffffff);
        this.transparent = false;
        this.opacity = 1;
    };

    THREE.MeshBasicMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshBasicMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

    THREE.MeshPhongMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshPhongMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

    // Mesh class
    THREE.Mesh = function(geometry, material) {
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.children = [];
    };

    THREE.Mesh.prototype = {
        constructor: THREE.Mesh,
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Light classes
    THREE.Light = function(color, intensity) {
        this.type = 'Light';
        this.color = new THREE.Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.position = new THREE.Vector3();
    };

    THREE.AmbientLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

    THREE.DirectionalLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.target = { position: new THREE.Vector3() };
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500,
                left: -5,
                right: 5,
                top: 5,
                bottom: -5
            }
        };
        this.castShadow = false;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

    THREE.PointLight = function(color, intensity, distance, decay) {
        THREE.Light.call(this, color, intensity);
        this.type = 'PointLight';
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500
            }
        };
        this.castShadow = false;
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;

    // Texture classes
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.image = image;
        this.needsUpdate = false;
        this.colorSpace = THREE.SRGBColorSpace;
        this.wrapS = wrapS || THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT || THREE.ClampToEdgeWrapping;
    };

    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

    THREE.TextureLoader = function() {};
    THREE.TextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var image = new Image();
        image.onload = function() {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        };
        image.onerror = onError;
        image.src = url;
        return texture;
    };

    // CanvasTexture class
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.isTexture = true;
        this.uuid = THREE.MathUtils.generateUUID();
        this.image = canvas;
        this.mapping = mapping || THREE.UVMapping;
        this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipmapLinearFilter;
        this.format = format !== undefined ? format : THREE.RGBAFormat;
        this.type = type !== undefined ? type : THREE.UnsignedByteType;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.flipY = false;
        this.needsUpdate = true;
        this.repeat = new THREE.Vector2(1, 1);
        this.offset = new THREE.Vector2(0, 0);
    };

    THREE.CanvasTexture.prototype = {
        constructor: THREE.CanvasTexture,
        
        dispose: function() {
            // Cleanup logic
        }
    };

    // RingGeometry class
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius || 0.5,
            outerRadius: outerRadius || 1,
            thetaSegments: thetaSegments || 8,
            phiSegments: phiSegments || 1,
            thetaStart: thetaStart || 0,
            thetaLength: thetaLength || Math.PI * 2
        };
        
        // Simple ring geometry data
        this.vertices = [];
        this.faces = [];
        this.uvs = [];
        
        // Generate ring vertices
        var innerR = this.parameters.innerRadius;
        var outerR = this.parameters.outerRadius;
        var segments = this.parameters.thetaSegments;
        
        for (var i = 0; i <= segments; i++) {
            var angle = (i / segments) * Math.PI * 2;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            
            // Inner vertex
            this.vertices.push(innerR * cos, 0, innerR * sin);
            // Outer vertex
            this.vertices.push(outerR * cos, 0, outerR * sin);
        }
    };

    THREE.RingGeometry.prototype = {
        constructor: THREE.RingGeometry
    };

    // Constants
    THREE.SRGBColorSpace = 'srgb';
    THREE.LinearSRGBColorSpace = 'srgb-linear';
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.BasicShadowMap = 0;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.RepeatWrapping = 1000;
    THREE.LinearFilter = 1006;
    THREE.LinearMipmapLinearFilter = 1008;
    THREE.RGBAFormat = 1023;
    THREE.UnsignedByteType = 1009;
    THREE.UVMapping = 300;
    THREE.sRGBEncoding = 3001;

    // Fog class
    THREE.Fog = function(color, near, far) {
        this.name = '';
        this.color = new THREE.Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
        this.isFog = true;
    };

    THREE.Fog.prototype = {
        constructor: THREE.Fog,
        
        clone: function() {
            return new THREE.Fog(this.color, this.near, this.far);
        }
    };

    // Group class
    THREE.Group = function() {
        this.type = 'Group';
        this.children = [];
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
    };

    THREE.Group.prototype = {
        constructor: THREE.Group,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Export THREE to global scope
    global.THREE = THREE;
    
    console.log('Three.js Custom Implementation r170 loaded successfully');

})(typeof window !== 'undefined' ? window : this);