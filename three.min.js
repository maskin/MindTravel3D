/**
 * Minimal Three.js Implementation for MindTravel3D
 * Compatible with official Three.js API structure
 * Version: Custom r170-compatible
 */

(function(global) {
    'use strict';

    // Core Three.js namespace
    var THREE = {};
    
    // Version info
    THREE.REVISION = '170';
    
    // Math utilities
    THREE.MathUtils = {
        generateUUID: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    // Vector2 class
    THREE.Vector2 = function(x, y) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
    };

    THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        
        set: function(x, y) {
            this.x = x; this.y = y;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y;
            return this;
        }
    };

    // Vector3 class
    THREE.Vector3 = function(x, y, z) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
        this.z = z !== undefined ? z : 0;
    };

    THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        
        set: function(x, y, z) {
            this.x = x; this.y = y; this.z = z;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y; this.z = v.z;
            return this;
        },
        
        add: function(v) {
            this.x += v.x; this.y += v.y; this.z += v.z;
            return this;
        },
        
        normalize: function() {
            var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (length > 0) {
                this.x /= length; this.y /= length; this.z /= length;
            }
            return this;
        }
    };

    // Color class
    THREE.Color = function(r, g, b) {
        this.r = r !== undefined ? r : 1;
        this.g = g !== undefined ? g : 1;
        this.b = b !== undefined ? b : 1;
    };

    THREE.Color.prototype = {
        constructor: THREE.Color,
        
        setHex: function(hex) {
            this.r = ((hex >> 16) & 255) / 255;
            this.g = ((hex >> 8) & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        }
    };

    // Scene class
    THREE.Scene = function() {
        this.type = 'Scene';
        this.children = [];
        this.background = null;
    };

    THREE.Scene.prototype = {
        constructor: THREE.Scene,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            // Call callback on this object
            callback(this);
            
            // Recursively traverse all children
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Camera base class
    THREE.Camera = function() {
        this.type = 'Camera';
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.matrixWorldInverse = new THREE.Matrix4();
        this.projectionMatrix = new THREE.Matrix4();
    };

    // PerspectiveCamera
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
        THREE.Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.updateProjectionMatrix();
    };

    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Simplified projection matrix calculation
        this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simplified lookAt implementation
        if (typeof x === 'object') {
            // lookAt(vector)
            console.log('Camera lookAt vector:', x);
        } else {
            // lookAt(x, y, z)
            console.log('Camera lookAt coordinates:', x, y, z);
        }
        // In a real implementation, this would update the camera's rotation
        // For now, we'll just log the call
    };

    // Matrix4 class (simplified)
    THREE.Matrix4 = function() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    };

    // WebGL Renderer (simplified)
    THREE.WebGLRenderer = function(parameters) {
        parameters = parameters || {};
        
        this.domElement = parameters.canvas || document.createElement('canvas');
        this.context = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');
        
        this.shadowMap = {
            enabled: false,
            type: THREE.PCFShadowMap
        };
        
        this.outputColorSpace = THREE.SRGBColorSpace;
        
        // Add rendering state tracking
        this.renderCount = 0;
        this.lastLogTime = 0;
    };

    THREE.WebGLRenderer.prototype = {
        constructor: THREE.WebGLRenderer,
        
        setSize: function(width, height, updateStyle) {
            this.domElement.width = width;
            this.domElement.height = height;
            
            if (updateStyle !== false) {
                this.domElement.style.width = width + 'px';
                this.domElement.style.height = height + 'px';
            }
            
            if (this.context) {
                this.context.viewport(0, 0, width, height);
            }
        },
        
        render: function(scene, camera) {
            if (!this.context) return;
            
            var gl = this.context;
            this.renderCount++;
            var now = Date.now();
            
            // Clear the WebGL canvas with a visible color
            gl.clearColor(0.1, 0.1, 0.3, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            
            // 3D„Éì„É•„Éº„ÅÆÊèèÁîª (WebGL canvas with overlay)
            this.render3DView(scene, camera);
        },
        
        render3DView: function(scene, camera) {
            var gl = this.context;
            
            try {
                if (!gl) {
                    console.error('No WebGL context available for 3D view');
                    return;
                }
                
                // Get canvas and check dimensions
                var canvas3D = document.getElementById('gameCanvas3D');
                if (!canvas3D) {
                    console.error('gameCanvas3D element not found');
                    return;
                }
                
                if (this.renderCount % 120 === 0) {
                    console.log('Canvas3D dimensions:', {
                        width: canvas3D.width,
                        height: canvas3D.height,
                        clientWidth: canvas3D.clientWidth,
                        clientHeight: canvas3D.clientHeight
                    });
                }
                
                // Clear WebGL canvas with a visible color for 3D view
                gl.clearColor(0.2, 0.4, 0.8, 1.0); // Brighter blue
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);
                gl.viewport(0, 0, canvas3D.width, canvas3D.height);
                
                // Draw 3D maze
                this.draw3DMaze();
                
            } catch (error) {
                console.warn('WebGL rendering error:', error);
                if (gl) {
                    gl.clearColor(0.8, 0.2, 0.2, 1.0); // Red to indicate error
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
            }
        },
        
        draw3DMaze: function() {
            // 3DÁ´ã‰ΩìËø∑Ë∑Ø„ÅÆÊèèÁîª„ÇíÂÆüË£Ö
            if (window.gameManager && window.gameManager.mazeGenerator && window.gameManager.mazeGenerator.maze) {
                var maze = window.gameManager.mazeGenerator.maze;
                var mazeWidth = window.gameManager.mazeGenerator.width;
                var mazeHeight = window.gameManager.mazeGenerator.height;
                
                // Áõ¥Êé•„Ç™„Éº„Éê„Éº„É¨„Ç§„Ç≠„É£„É≥„Éê„Çπ„Å´3DËø∑Ë∑Ø„ÇíÊèèÁîª
                this.drawRealtime3DMaze(maze, mazeWidth, mazeHeight);
            } else {
                // „Éá„Éê„ÉÉ„Ç∞: „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥„ÇíË°®Á§∫
                this.drawTestPattern3D();
            }
        },
        
        drawCanvasToWebGL: function(sourceCanvas) {
            // Simple method to display 2D canvas content in WebGL context
            try {
                var gl = this.context;
                var canvas3D = document.getElementById('gameCanvas3D');
                
                if (gl && canvas3D) {
                    // Clear with the background color from the source canvas
                    gl.clearColor(0.5, 0.8, 1.0, 1.0); // Sky blue
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Draw a simple test pattern directly to WebGL canvas using 2D overlay
                    // This is a workaround - we'll draw on a 2D canvas overlay
                    this.drawTestPattern3D();
                    
                    // Log that we're "rendering" the 3D view
                    if (this.renderCount % 60 === 0) {
                        console.log('üé® WebGL 3D view simulated (frame ' + this.renderCount + ')');
                    }
                }
            } catch (error) {
                console.warn('WebGL texture update failed:', error);
            }
        },
        
        drawRealtime3DMaze: function(maze, mazeWidth, mazeHeight) {
            // „É™„Ç¢„É´„Çø„Ç§„É†3DËø∑Ë∑ØÊèèÁîª
            var canvas3D = document.getElementById('gameCanvas3D');
            if (!canvas3D) return;
            
            var overlayId = 'canvas3DOverlay';
            var overlay = document.getElementById(overlayId);
            
            if (!overlay) {
                overlay = document.createElement('canvas');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';
                canvas3D.parentNode.style.position = 'relative';
                canvas3D.parentNode.appendChild(overlay);
            }
            
            overlay.width = canvas3D.width;
            overlay.height = canvas3D.height;
            overlay.style.width = canvas3D.style.width;
            overlay.style.height = canvas3D.style.height;
            
            var ctx = overlay.getContext('2d');
            if (ctx && maze) {
                // „Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                
                // „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„Å®ÂõûËª¢„ÇíÂèñÂæó
                var playerX = 1.5;
                var playerZ = 1.5;
                var playerAngle = 0;
                
                if (window.gameManager && window.gameManager.gameEngine && window.gameManager.gameEngine.playerPosition) {
                    playerX = window.gameManager.gameEngine.playerPosition.x;
                    playerZ = window.gameManager.gameEngine.playerPosition.z;
                    playerAngle = window.gameManager.gameEngine.playerRotation || 0;
                }
                
                // 3DËø∑Ë∑Ø„ÇíÊèèÁîª
                this.draw3DPerspectiveMaze(ctx, overlay, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle);
            }
        },
        
        draw3DPerspectiveMaze: function(ctx, canvas, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle) {
            var width = canvas.width;
            var height = canvas.height;
            var centerY = height / 2;
            
            // ËÉåÊôØ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ÔºàÁ©∫„Å®Âú∞Èù¢Ôºâ
            var gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#4A90E2'); // Á©∫Ëâ≤
            gradient.addColorStop(0.5, '#7BB3F0');
            gradient.addColorStop(1, '#2D5AA0'); // Âú∞Âπ≥Á∑ö
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Â∫ä„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            var floorGradient = ctx.createLinearGradient(0, centerY, 0, height);
            floorGradient.addColorStop(0, '#4D4D4D');
            floorGradient.addColorStop(1, '#2A2A2A');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, centerY, width, height - centerY);
            
            // Ë¶ñÈáéËßí„Å®ÊúÄÂ§ßË∑ùÈõ¢
            var fov = Math.PI / 3; // 60Â∫¶
            var maxDistance = 12;
            
            // „É¨„Ç§„Ç≠„É£„Çπ„ÉÜ„Ç£„É≥„Ç∞„ÅßÂ£Å„ÇíÊèèÁîª
            for (var ray = 0; ray < width; ray += 1) {
                var rayAngle = playerAngle + (ray - width/2) * fov / width;
                var distance = this.castRay(maze, mazeWidth, mazeHeight, playerX, playerZ, rayAngle, maxDistance);
                
                if (distance < maxDistance) {
                    // Â£Å„ÅÆÈ´ò„Åï„ÇíË∑ùÈõ¢„Å´Âü∫„Å•„ÅÑ„Å¶Ë®àÁÆó
                    var wallHeight = (height * 0.8) / (distance + 0.1);
                    var wallTop = centerY - wallHeight / 2;
                    var wallBottom = centerY + wallHeight / 2;
                    
                    // Ë∑ùÈõ¢„Å´Âü∫„Å•„ÅèÊòéÂ∫¶„Å®Ëâ≤
                    var brightness = Math.max(0.2, 1 - distance / maxDistance);
                    
                    // Â£Å„ÅÆËâ≤„ÇíË®àÁÆóÔºàËå∂Ëâ≤Á≥ªÔºâ
                    var r = Math.floor(139 * brightness);
                    var g = Math.floor(69 * brightness);
                    var b = Math.floor(19 * brightness);
                    
                    // Â£Å„ÇíÊèèÁîª
                    ctx.strokeStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(ray, wallTop);
                    ctx.lineTo(ray, wallBottom);
                    ctx.stroke();
                    
                    // Èô∞ÂΩ±ÂäπÊûú„ÇíËøΩÂä†
                    if (wallHeight > 50) {
                        var shadowBrightness = brightness * 0.7;
                        var shadowR = Math.floor(139 * shadowBrightness);
                        var shadowG = Math.floor(69 * shadowBrightness);
                        var shadowB = Math.floor(19 * shadowBrightness);
                        ctx.strokeStyle = 'rgb(' + shadowR + ',' + shadowG + ',' + shadowB + ')';
                        ctx.beginPath();
                        ctx.moveTo(ray + 0.5, wallTop);
                        ctx.lineTo(ray + 0.5, wallBottom);
                        ctx.stroke();
                    }
                }
            }
            
            // UIÊÉÖÂ†±„ÇíË°®Á§∫
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('3DËø∑Ë∑Ø„Éì„É•„Éº', 20, 40);
            
            ctx.font = '12px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('‰ΩçÁΩÆ: (' + playerX.toFixed(1) + ', ' + playerZ.toFixed(1) + ')', 20, 60);
            ctx.fillText('ÊñπÂêë: ' + (playerAngle * 180 / Math.PI).toFixed(0) + '¬∞', 20, 80);
            
            // „Éü„Éã„Éû„ÉÉ„Éó„ÇíÂè≥‰∏ä„Å´Ë°®Á§∫
            this.drawMiniMap(ctx, canvas, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle);
        },
        
        drawMiniMap: function(ctx, canvas, maze, mazeWidth, mazeHeight, playerX, playerZ, playerAngle) {
            var miniSize = 120;
            var miniX = canvas.width - miniSize - 20;
            var miniY = 20;
            
            // „Éü„Éã„Éû„ÉÉ„Éó„ÅÆËÉåÊôØ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(miniX, miniY, miniSize, miniSize);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.strokeRect(miniX, miniY, miniSize, miniSize);
            
            // „Çπ„Ç±„Éº„É´Ë®àÁÆó
            var scale = miniSize / Math.max(mazeWidth, mazeHeight);
            var offsetX = miniX + (miniSize - mazeWidth * scale) / 2;
            var offsetY = miniY + (miniSize - mazeHeight * scale) / 2;
            
            // Ëø∑Ë∑Ø„ÅÆÂ£Å„ÇíÊèèÁîª
            ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
            for (var y = 0; y < mazeHeight; y++) {
                for (var x = 0; x < mazeWidth; x++) {
                    if (maze[y] && maze[y][x] === 1) {
                        ctx.fillRect(
                            offsetX + x * scale,
                            offsetY + y * scale,
                            scale,
                            scale
                        );
                    }
                }
            }
            
            // „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„ÇíË°®Á§∫
            ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
            var playerScreenX = offsetX + playerX * scale;
            var playerScreenY = offsetY + playerZ * scale;
            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // „Éó„É¨„Ç§„É§„Éº„ÅÆÊñπÂêë„ÇíË°®Á§∫
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerScreenX, playerScreenY);
            ctx.lineTo(
                playerScreenX + Math.sin(playerAngle) * 8,
                playerScreenY + Math.cos(playerAngle) * 8
            );
            ctx.stroke();
        },
        
        drawTestPattern3D: function() {
            // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥„ÇíÊèèÁîªÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
            var canvas3D = document.getElementById('gameCanvas3D');
            if (!canvas3D) return;
            
            var overlayId = 'canvas3DOverlay';
            var overlay = document.getElementById(overlayId);
            
            if (!overlay) {
                overlay = document.createElement('canvas');
                overlay.id = overlayId;
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';
                canvas3D.parentNode.style.position = 'relative';
                canvas3D.parentNode.appendChild(overlay);
            }
            
            overlay.width = canvas3D.width;
            overlay.height = canvas3D.height;
            overlay.style.width = canvas3D.style.width;
            overlay.style.height = canvas3D.style.height;
            
            var ctx = overlay.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '24px Arial';
                ctx.fillText('Ëø∑Ë∑Ø„Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...', 50, 50);
                
                ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.fillRect(100, 100, 200, 100);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '16px Arial';
                ctx.fillText('Canvas: ' + overlay.width + 'x' + overlay.height, 110, 130);
                ctx.fillText('Frame: ' + this.renderCount, 110, 150);
            }
        },
        
        
        castRay: function(maze, mazeWidth, mazeHeight, startX, startZ, angle, maxDistance) {
            var dx = Math.cos(angle) * 0.1;
            var dz = Math.sin(angle) * 0.1;
            var x = startX;
            var z = startZ;
            var distance = 0;
            
            while (distance < maxDistance) {
                x += dx;
                z += dz;
                distance += 0.1;
                
                var mapX = Math.floor(x);
                var mapZ = Math.floor(z);
                
                if (mapX < 0 || mapX >= mazeWidth || mapZ < 0 || mapZ >= mazeHeight) {
                    return distance;
                }
                
                if (maze[mapZ] && maze[mapZ][mapX] === 1) {
                    return distance;
                }
            }
            
            return maxDistance;
        },
        
        
        clear: function() {
            if (!this.context) return;
            this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
        },
        
        getContext: function() {
            return this.context;
        },
        
        setClearColor: function(color, alpha) {
            // Set clear color
        },
        
        setPixelRatio: function(value) {
            // Set pixel ratio
        },
        
        dispose: function() {
            // Cleanup
        }
    };

    // Geometry classes
    THREE.BufferGeometry = function() {
        this.type = 'BufferGeometry';
        this.attributes = {};
        this.isBufferGeometry = true;
    };

    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            depth: depth || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1,
            depthSegments: depthSegments || 1
        };
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1
        };
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'CylinderGeometry';
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'SphereGeometry';
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

    // Material classes
    THREE.Material = function() {
        this.type = 'Material';
        this.color = new THREE.Color(0xffffff);
        this.transparent = false;
        this.opacity = 1;
    };

    THREE.MeshBasicMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshBasicMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

    THREE.MeshPhongMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshPhongMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

    // Mesh class
    THREE.Mesh = function(geometry, material) {
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.children = [];
    };

    THREE.Mesh.prototype = {
        constructor: THREE.Mesh,
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Light classes
    THREE.Light = function(color, intensity) {
        this.type = 'Light';
        this.color = new THREE.Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.position = new THREE.Vector3();
    };

    THREE.AmbientLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

    THREE.DirectionalLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.target = { position: new THREE.Vector3() };
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500,
                left: -5,
                right: 5,
                top: 5,
                bottom: -5
            }
        };
        this.castShadow = false;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

    THREE.PointLight = function(color, intensity, distance, decay) {
        THREE.Light.call(this, color, intensity);
        this.type = 'PointLight';
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500
            }
        };
        this.castShadow = false;
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;

    // Texture classes
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.image = image;
        this.needsUpdate = false;
        this.colorSpace = THREE.SRGBColorSpace;
        this.wrapS = wrapS || THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT || THREE.ClampToEdgeWrapping;
    };

    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

    THREE.TextureLoader = function() {};
    THREE.TextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var image = new Image();
        image.onload = function() {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        };
        image.onerror = onError;
        image.src = url;
        return texture;
    };

    // CanvasTexture class
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.isTexture = true;
        this.uuid = THREE.MathUtils.generateUUID();
        this.image = canvas;
        this.mapping = mapping || THREE.UVMapping;
        this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipmapLinearFilter;
        this.format = format !== undefined ? format : THREE.RGBAFormat;
        this.type = type !== undefined ? type : THREE.UnsignedByteType;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.flipY = false;
        this.needsUpdate = true;
        this.repeat = new THREE.Vector2(1, 1);
        this.offset = new THREE.Vector2(0, 0);
    };

    THREE.CanvasTexture.prototype = {
        constructor: THREE.CanvasTexture,
        
        dispose: function() {
            // Cleanup logic
        }
    };

    // RingGeometry class
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius || 0.5,
            outerRadius: outerRadius || 1,
            thetaSegments: thetaSegments || 8,
            phiSegments: phiSegments || 1,
            thetaStart: thetaStart || 0,
            thetaLength: thetaLength || Math.PI * 2
        };
        
        // Simple ring geometry data
        this.vertices = [];
        this.faces = [];
        this.uvs = [];
        
        // Generate ring vertices
        var innerR = this.parameters.innerRadius;
        var outerR = this.parameters.outerRadius;
        var segments = this.parameters.thetaSegments;
        
        for (var i = 0; i <= segments; i++) {
            var angle = (i / segments) * Math.PI * 2;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            
            // Inner vertex
            this.vertices.push(innerR * cos, 0, innerR * sin);
            // Outer vertex
            this.vertices.push(outerR * cos, 0, outerR * sin);
        }
    };

    THREE.RingGeometry.prototype = {
        constructor: THREE.RingGeometry
    };

    // Constants
    THREE.SRGBColorSpace = 'srgb';
    THREE.LinearSRGBColorSpace = 'srgb-linear';
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.BasicShadowMap = 0;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.RepeatWrapping = 1000;
    THREE.LinearFilter = 1006;
    THREE.LinearMipmapLinearFilter = 1008;
    THREE.RGBAFormat = 1023;
    THREE.UnsignedByteType = 1009;
    THREE.UVMapping = 300;
    THREE.sRGBEncoding = 3001;

    // Fog class
    THREE.Fog = function(color, near, far) {
        this.name = '';
        this.color = new THREE.Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
        this.isFog = true;
    };

    THREE.Fog.prototype = {
        constructor: THREE.Fog,
        
        clone: function() {
            return new THREE.Fog(this.color, this.near, this.far);
        }
    };

    // Group class
    THREE.Group = function() {
        this.type = 'Group';
        this.children = [];
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
    };

    THREE.Group.prototype = {
        constructor: THREE.Group,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Export THREE to global scope
    global.THREE = THREE;
    
    console.log('Three.js Custom Implementation r170 loaded successfully');

})(typeof window !== 'undefined' ? window : this);