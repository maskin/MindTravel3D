/**
 * Minimal Three.js Implementation for MindTravel3D
 * Compatible with official Three.js API structure
 * Version: Custom r170-compatible
 */

(function(global) {
    'use strict';

    // Core Three.js namespace
    var THREE = {};
    
    // Version info
    THREE.REVISION = '170';
    
    // Math utilities
    THREE.MathUtils = {
        generateUUID: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    // Vector2 class
    THREE.Vector2 = function(x, y) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
    };

    THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        
        set: function(x, y) {
            this.x = x; this.y = y;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y;
            return this;
        }
    };

    // Vector3 class
    THREE.Vector3 = function(x, y, z) {
        this.x = x !== undefined ? x : 0;
        this.y = y !== undefined ? y : 0;
        this.z = z !== undefined ? z : 0;
    };

    THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        
        set: function(x, y, z) {
            this.x = x; this.y = y; this.z = z;
            return this;
        },
        
        copy: function(v) {
            this.x = v.x; this.y = v.y; this.z = v.z;
            return this;
        },
        
        add: function(v) {
            this.x += v.x; this.y += v.y; this.z += v.z;
            return this;
        },
        
        normalize: function() {
            var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (length > 0) {
                this.x /= length; this.y /= length; this.z /= length;
            }
            return this;
        }
    };

    // Color class
    THREE.Color = function(r, g, b) {
        this.r = r !== undefined ? r : 1;
        this.g = g !== undefined ? g : 1;
        this.b = b !== undefined ? b : 1;
    };

    THREE.Color.prototype = {
        constructor: THREE.Color,
        
        setHex: function(hex) {
            this.r = ((hex >> 16) & 255) / 255;
            this.g = ((hex >> 8) & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        }
    };

    // Scene class
    THREE.Scene = function() {
        this.type = 'Scene';
        this.children = [];
        this.background = null;
    };

    THREE.Scene.prototype = {
        constructor: THREE.Scene,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            // Call callback on this object
            callback(this);
            
            // Recursively traverse all children
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Camera base class
    THREE.Camera = function() {
        this.type = 'Camera';
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.matrixWorldInverse = new THREE.Matrix4();
        this.projectionMatrix = new THREE.Matrix4();
    };

    // PerspectiveCamera
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
        THREE.Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.updateProjectionMatrix();
    };

    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Simplified projection matrix calculation
        this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simplified lookAt implementation
        if (typeof x === 'object') {
            // lookAt(vector)
            console.log('Camera lookAt vector:', x);
        } else {
            // lookAt(x, y, z)
            console.log('Camera lookAt coordinates:', x, y, z);
        }
        // In a real implementation, this would update the camera's rotation
        // For now, we'll just log the call
    };

    // Matrix4 class (simplified)
    THREE.Matrix4 = function() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    };

    // WebGL Renderer (simplified)
    THREE.WebGLRenderer = function(parameters) {
        parameters = parameters || {};
        
        this.domElement = parameters.canvas || document.createElement('canvas');
        this.context = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');
        
        this.shadowMap = {
            enabled: false,
            type: THREE.PCFShadowMap
        };
        
        this.outputColorSpace = THREE.SRGBColorSpace;
    };

    THREE.WebGLRenderer.prototype = {
        constructor: THREE.WebGLRenderer,
        
        setSize: function(width, height, updateStyle) {
            this.domElement.width = width;
            this.domElement.height = height;
            
            if (updateStyle !== false) {
                this.domElement.style.width = width + 'px';
                this.domElement.style.height = height + 'px';
            }
            
            if (this.context) {
                this.context.viewport(0, 0, width, height);
            }
        },
        
        render: function(scene, camera) {
            if (!this.context) return;
            
            // Clear canvas
            this.context.clearColor(0.0, 0.0, 0.0, 1.0);
            this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
            
            // Simple rendering - just clear for now
            // Real implementation would render all scene objects
        },
        
        clear: function() {
            if (!this.context) return;
            this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
        },
        
        getContext: function() {
            return this.context;
        },
        
        setClearColor: function(color, alpha) {
            // Set clear color
        },
        
        setPixelRatio: function(value) {
            // Set pixel ratio
        },
        
        dispose: function() {
            // Cleanup
        }
    };

    // Geometry classes
    THREE.BufferGeometry = function() {
        this.type = 'BufferGeometry';
        this.attributes = {};
        this.isBufferGeometry = true;
    };

    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            depth: depth || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1,
            depthSegments: depthSegments || 1
        };
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
        THREE.BufferGeometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width || 1,
            height: height || 1,
            widthSegments: widthSegments || 1,
            heightSegments: heightSegments || 1
        };
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'CylinderGeometry';
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        THREE.BufferGeometry.call(this);
        this.type = 'SphereGeometry';
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

    // Material classes
    THREE.Material = function() {
        this.type = 'Material';
        this.color = new THREE.Color(0xffffff);
        this.transparent = false;
        this.opacity = 1;
    };

    THREE.MeshBasicMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshBasicMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

    THREE.MeshPhongMaterial = function(parameters) {
        THREE.Material.call(this);
        this.type = 'MeshPhongMaterial';
        parameters = parameters || {};
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.transparent !== undefined) this.transparent = parameters.transparent;
        if (parameters.opacity !== undefined) this.opacity = parameters.opacity;
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

    // Mesh class
    THREE.Mesh = function(geometry, material) {
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.children = [];
    };

    THREE.Mesh.prototype = {
        constructor: THREE.Mesh,
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Light classes
    THREE.Light = function(color, intensity) {
        this.type = 'Light';
        this.color = new THREE.Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.position = new THREE.Vector3();
    };

    THREE.AmbientLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

    THREE.DirectionalLight = function(color, intensity) {
        THREE.Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.target = { position: new THREE.Vector3() };
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500,
                left: -5,
                right: 5,
                top: 5,
                bottom: -5
            }
        };
        this.castShadow = false;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

    THREE.PointLight = function(color, intensity, distance, decay) {
        THREE.Light.call(this, color, intensity);
        this.type = 'PointLight';
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: {
                near: 0.5,
                far: 500
            }
        };
        this.castShadow = false;
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;

    // Texture classes
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.image = image;
        this.needsUpdate = false;
        this.colorSpace = THREE.SRGBColorSpace;
        this.wrapS = wrapS || THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT || THREE.ClampToEdgeWrapping;
    };

    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

    THREE.TextureLoader = function() {};
    THREE.TextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var image = new Image();
        image.onload = function() {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        };
        image.onerror = onError;
        image.src = url;
        return texture;
    };

    // CanvasTexture class
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        this.isTexture = true;
        this.uuid = THREE.MathUtils.generateUUID();
        this.image = canvas;
        this.mapping = mapping || THREE.UVMapping;
        this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipmapLinearFilter;
        this.format = format !== undefined ? format : THREE.RGBAFormat;
        this.type = type !== undefined ? type : THREE.UnsignedByteType;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.flipY = false;
        this.needsUpdate = true;
        this.repeat = new THREE.Vector2(1, 1);
        this.offset = new THREE.Vector2(0, 0);
    };

    THREE.CanvasTexture.prototype = {
        constructor: THREE.CanvasTexture,
        
        dispose: function() {
            // Cleanup logic
        }
    };

    // RingGeometry class
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius || 0.5,
            outerRadius: outerRadius || 1,
            thetaSegments: thetaSegments || 8,
            phiSegments: phiSegments || 1,
            thetaStart: thetaStart || 0,
            thetaLength: thetaLength || Math.PI * 2
        };
        
        // Simple ring geometry data
        this.vertices = [];
        this.faces = [];
        this.uvs = [];
        
        // Generate ring vertices
        var innerR = this.parameters.innerRadius;
        var outerR = this.parameters.outerRadius;
        var segments = this.parameters.thetaSegments;
        
        for (var i = 0; i <= segments; i++) {
            var angle = (i / segments) * Math.PI * 2;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            
            // Inner vertex
            this.vertices.push(innerR * cos, 0, innerR * sin);
            // Outer vertex
            this.vertices.push(outerR * cos, 0, outerR * sin);
        }
    };

    THREE.RingGeometry.prototype = {
        constructor: THREE.RingGeometry
    };

    // Constants
    THREE.SRGBColorSpace = 'srgb';
    THREE.LinearSRGBColorSpace = 'srgb-linear';
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.BasicShadowMap = 0;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.RepeatWrapping = 1000;
    THREE.LinearFilter = 1006;
    THREE.LinearMipmapLinearFilter = 1008;
    THREE.RGBAFormat = 1023;
    THREE.UnsignedByteType = 1009;
    THREE.UVMapping = 300;
    THREE.sRGBEncoding = 3001;

    // Fog class
    THREE.Fog = function(color, near, far) {
        this.name = '';
        this.color = new THREE.Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
        this.isFog = true;
    };

    THREE.Fog.prototype = {
        constructor: THREE.Fog,
        
        clone: function() {
            return new THREE.Fog(this.color, this.near, this.far);
        }
    };

    // Group class
    THREE.Group = function() {
        this.type = 'Group';
        this.children = [];
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
    };

    THREE.Group.prototype = {
        constructor: THREE.Group,
        
        add: function(object) {
            this.children.push(object);
            object.parent = this;
        },
        
        remove: function(object) {
            var index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
                object.parent = null;
            }
        },
        
        traverse: function(callback) {
            callback(this);
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.traverse) {
                    child.traverse(callback);
                } else {
                    callback(child);
                }
            }
        }
    };

    // Export THREE to global scope
    global.THREE = THREE;
    
    console.log('Three.js Custom Implementation r170 loaded successfully');

})(typeof window !== 'undefined' ? window : this);