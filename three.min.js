// Functional Three.js implementation for 3D maze rendering
(function() {
    'use strict';
    
    // Basic 3D math utilities
    function Vector3(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    Vector3.prototype.set = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    
    function Matrix4() {
        this.elements = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    }
    
    // Scene class
    function Scene() {
        this.children = [];
        this.fog = null;
        this.background = null;
    }
    
    Scene.prototype.add = function(object) {
        this.children.push(object);
        object.parent = this;
    };
    
    Scene.prototype.remove = function(object) {
        const index = this.children.indexOf(object);
        if (index > -1) {
            this.children.splice(index, 1);
            object.parent = null;
        }
    };
    
    Scene.prototype.traverse = function(callback) {
        callback(this);
        for (let child of this.children) {
            if (child.traverse) {
                child.traverse(callback);
            } else {
                callback(child);
            }
        }
    };
    
    // Basic Object3D
    function Object3D() {
        this.position = new Vector3();
        this.rotation = new Vector3();
        this.scale = new Vector3(1, 1, 1);
        this.parent = null;
        this.children = [];
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.visible = true;
    }
    
    Object3D.prototype.add = function(object) {
        this.children.push(object);
        object.parent = this;
    };
    
    Object3D.prototype.updateMatrixWorld = function() {
        // Basic matrix update - for simplicity
    };
    
    // Camera
    function PerspectiveCamera(fov, aspect, near, far) {
        Object3D.call(this);
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.projectionMatrix = new Matrix4();
        this.matrixWorldInverse = new Matrix4();
    }
    
    PerspectiveCamera.prototype = Object.create(Object3D.prototype);
    PerspectiveCamera.prototype.constructor = PerspectiveCamera;
    
    PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simple look-at implementation for rendering
        this.lookDirection = { x: x - this.position.x, y: y - this.position.y, z: z - this.position.z };
    };
    
    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Update projection matrix
    };
    
    // WebGL Renderer
    function WebGLRenderer(parameters = {}) {
        this.canvas = parameters.canvas || document.createElement('canvas');
        this.context = null;
        this.shadowMap = { enabled: false, type: null };
        this.fog = false;
        
        // Force 2D fallback for now as our WebGL implementation is incomplete
        this.context = this.canvas.getContext('2d');
        this.is2D = true;
        
        console.log('WebGLRenderer initialized with 2D fallback');
        
        this.clearColor = { r: 0, g: 0, b: 0 };
    }
    
    WebGLRenderer.prototype.setSize = function(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
    };
    
    WebGLRenderer.prototype.setPixelRatio = function(ratio) {
        // Set pixel ratio
    };
    
    WebGLRenderer.prototype.setClearColor = function(color) {
        this.clearColor = {
            r: (color >> 16) & 255,
            g: (color >> 8) & 255,
            b: color & 255
        };
    };
    
    WebGLRenderer.prototype.render = function(scene, camera) {
        if (!this.context) return;
        
        console.log('Renderer.render called - is2D:', this.is2D, 'context type:', this.is2D ? '2D' : 'WebGL');
        
        if (this.is2D) {
            this.render2D(scene, camera);
        } else {
            this.renderWebGL(scene, camera);
        }
    };
    
    WebGLRenderer.prototype.render2D = function(scene, camera) {
        const ctx = this.context;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        ctx.fillStyle = `rgb(${this.clearColor.r}, ${this.clearColor.g}, ${this.clearColor.b})`;
        ctx.fillRect(0, 0, width, height);
        
        // Simple 3D to 2D projection for maze visualization
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 20; // Scale factor for projection
        
        // Camera position and direction
        const camX = camera.position.x;
        const camZ = camera.position.z;
        const camY = camera.position.y;
        
        // Get camera direction
        let lookAngle = 0;
        if (camera.lookDirection) {
            lookAngle = Math.atan2(camera.lookDirection.x, camera.lookDirection.z);
        }
        
        console.log('Rendering frame - Camera:', { x: camX, y: camY, z: camZ }, 'Look angle:', lookAngle);
        
        // Count objects to render
        let wallCount = 0;
        let floorCount = 0;
        
        // Render maze walls and floor
        scene.traverse((object) => {
            if (object.geometry && object.material) {
                if (object.geometry.type === 'BoxGeometry') {
                    // Render wall as a rectangle in 3D perspective
                    this.renderBox(ctx, object, camera, centerX, centerY, scale, lookAngle);
                    wallCount++;
                } else if (object.geometry.type === 'PlaneGeometry') {
                    // Render floor
                    this.renderFloor(ctx, object, camera, centerX, centerY, scale, lookAngle);
                    floorCount++;
                } else if (object.geometry.type === 'CylinderGeometry') {
                    // Render goal
                    this.renderCylinder(ctx, object, camera, centerX, centerY, scale, lookAngle);
                }
            }
        });
        
        console.log('Rendered objects - Walls:', wallCount, 'Floor:', floorCount);
        
        // Debug info
        if (wallCount > 0 || floorCount > 0) {
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Arial';
            ctx.fillText(`Walls: ${wallCount}, Floor: ${floorCount}`, 10, height - 20);
            ctx.fillText(`Camera: ${camX.toFixed(1)}, ${camZ.toFixed(1)}`, 10, height - 40);
        }
        
        // Draw simple first-person view indicators
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        
        // Draw crosshair
        ctx.beginPath();
        ctx.moveTo(centerX - 10, centerY);
        ctx.lineTo(centerX + 10, centerY);
        ctx.moveTo(centerX, centerY - 10);
        ctx.lineTo(centerX, centerY + 10);
        ctx.stroke();
    };
    
    WebGLRenderer.prototype.renderBox = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Simple 3D wall rendering
        const wall = object;
        const dx = wall.position.x - camera.position.x;
        const dz = wall.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 8) return; // Don't render distant walls
        if (distance < 0.1) return; // Don't render walls too close
        
        // Calculate wall position relative to camera view
        const wallAngle = Math.atan2(dx, dz);
        const relativeAngle = wallAngle - lookAngle;
        
        // Normalize angle
        let normalizedAngle = relativeAngle;
        while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
        while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
        
        // Only render walls in front of camera (wider field of view)
        if (Math.abs(normalizedAngle) > Math.PI / 1.5) return;
        
        // Project to screen with better scaling
        const screenX = centerX + Math.sin(normalizedAngle) * scale * 20;
        const wallHeight = Math.max(10, (3 / Math.max(distance, 0.5)) * scale * 30);
        const wallWidth = Math.max(5, (1 / Math.max(distance, 0.5)) * scale * 15);
        
        // Get material color
        let color = '#888888';
        if (wall.material && wall.material.color !== undefined) {
            const c = wall.material.color;
            color = `rgb(${((c >> 16) & 255)}, ${((c >> 8) & 255)}, ${(c & 255)})`;
        }
        
        // Draw wall with better visibility
        ctx.fillStyle = color;
        ctx.fillRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
        
        // Add border for better visibility
        ctx.strokeStyle = '#aaaaaa';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
        
        // Add some shading based on distance
        const shade = Math.max(0.2, 1 - distance / 8);
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - shade})`;
        ctx.fillRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
    };
    
    WebGLRenderer.prototype.renderFloor = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Simple floor grid rendering
        const floor = object;
        const dx = floor.position.x - camera.position.x;
        const dz = floor.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 6) return;
        
        // Draw floor tile
        const floorAngle = Math.atan2(dx, dz);
        const relativeAngle = floorAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 5;
        const screenY = centerY + distance * 8 + 50; // Floor appears lower
        
        if (screenY < centerY + 250 && screenY > centerY) { // Only render visible floor
            const floorSize = Math.max(2, 8 - distance);
            ctx.fillStyle = '#333333';
            ctx.fillRect(screenX - floorSize/2, screenY - floorSize/2, floorSize, floorSize);
        }
    };
    
    WebGLRenderer.prototype.renderCylinder = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Render goal cylinder
        const goal = object;
        const dx = goal.position.x - camera.position.x;
        const dz = goal.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 10) return;
        
        const goalAngle = Math.atan2(dx, dz);
        const relativeAngle = goalAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 10;
        const goalSize = (1 / Math.max(distance, 0.1)) * scale * 8;
        
        // Draw goal as red circle
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(screenX, centerY, goalSize, 0, 2 * Math.PI);
        ctx.fill();
        
        // Add glow effect
        ctx.strokeStyle = '#ff8888';
        ctx.lineWidth = 2;
        ctx.stroke();
    };
    
    WebGLRenderer.prototype.renderWebGL = function(scene, camera) {
        // Basic WebGL implementation would go here
        // For now, fall back to basic clearing
        const gl = this.context;
        gl.clearColor(this.clearColor.r / 255, this.clearColor.g / 255, this.clearColor.b / 255, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    
    // Geometry classes
    function BoxGeometry(width, height, depth) {
        this.type = 'BoxGeometry';
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    
    function PlaneGeometry(width, height) {
        this.type = 'PlaneGeometry';
        this.width = width;
        this.height = height;
    }
    
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments) {
        this.type = 'CylinderGeometry';
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radialSegments = radialSegments;
    }
    
    // Material classes
    function MeshLambertMaterial(parameters = {}) {
        this.type = 'MeshLambertMaterial';
        this.color = parameters.color || 0xffffff;
        this.emissive = parameters.emissive || 0x000000;
        this.transparent = parameters.transparent || false;
    }
    
    function MeshBasicMaterial(parameters = {}) {
        this.type = 'MeshBasicMaterial';
        this.color = parameters.color || 0xffffff;
        this.wireframe = parameters.wireframe || false;
    }
    
    // Mesh
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.geometry = geometry;
        this.material = material;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Mesh.prototype = Object.create(Object3D.prototype);
    Mesh.prototype.constructor = Mesh;
    
    // Lights
    function AmbientLight(color, intensity) {
        Object3D.call(this);
        this.type = 'AmbientLight';
        this.color = color;
        this.intensity = intensity;
    }
    
    AmbientLight.prototype = Object.create(Object3D.prototype);
    
    function SpotLight(color, intensity, distance, angle, decay) {
        Object3D.call(this);
        this.type = 'SpotLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
        this.angle = angle;
        this.decay = decay;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 1024, height: 1024 },
            camera: { near: 0.1, far: 20 }
        };
        this.target = new Object3D();
    }
    
    SpotLight.prototype = Object.create(Object3D.prototype);
    
    function DirectionalLight(color, intensity) {
        Object3D.call(this);
        this.type = 'DirectionalLight';
        this.color = color;
        this.intensity = intensity;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 2048, height: 2048 }
        };
    }
    
    DirectionalLight.prototype = Object.create(Object3D.prototype);
    
    function PointLight(color, intensity, distance) {
        Object3D.call(this);
        this.type = 'PointLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
    }
    
    PointLight.prototype = Object.create(Object3D.prototype);
    
    // Fog
    function Fog(color, near, far) {
        this.color = color;
        this.near = near;
        this.far = far;
    }
    
    // Constants
    const PCFSoftShadowMap = 'PCFSoftShadowMap';
    
    // Export THREE namespace
    window.THREE = {
        Scene: Scene,
        PerspectiveCamera: PerspectiveCamera,
        WebGLRenderer: WebGLRenderer,
        BoxGeometry: BoxGeometry,
        PlaneGeometry: PlaneGeometry,
        CylinderGeometry: CylinderGeometry,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        Mesh: Mesh,
        AmbientLight: AmbientLight,
        SpotLight: SpotLight,
        DirectionalLight: DirectionalLight,
        PointLight: PointLight,
        Fog: Fog,
        Vector3: Vector3,
        Matrix4: Matrix4,
        Object3D: Object3D,
        PCFSoftShadowMap: PCFSoftShadowMap
    };
    
    console.log('Functional Three.js implementation loaded');
})();