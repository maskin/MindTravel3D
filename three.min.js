// Minimal Three.js-compatible implementation for 3D maze rendering
(function() {
    'use strict';
    
    // Basic 3D math utilities
    function Vector3(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    Vector3.prototype.set = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    
    // Matrix4 stub
    function Matrix4() {
        this.elements = new Array(16).fill(0);
    }
    
    // Object3D base class
    function Object3D() {
        this.position = new Vector3();
        this.rotation = new Vector3();
        this.scale = new Vector3(1, 1, 1);
        this.children = [];
        this.parent = null;
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Object3D.prototype.add = function(object) {
        this.children.push(object);
        object.parent = this;
    };
    
    Object3D.prototype.remove = function(object) {
        const index = this.children.indexOf(object);
        if (index > -1) {
            this.children.splice(index, 1);
            object.parent = null;
        }
    };
    
    Object3D.prototype.traverse = function(callback) {
        callback(this);
        for (let child of this.children) {
            if (child.traverse) {
                child.traverse(callback);
            } else {
                callback(child);
            }
        }
    };
    
    Object3D.prototype.updateMatrixWorld = function() {
        // Basic matrix update - stub for compatibility
    };
    
    // Scene
    function Scene() {
        Object3D.call(this);
        this.fog = null;
    }
    Scene.prototype = Object.create(Object3D.prototype);
    Scene.prototype.constructor = Scene;
    
    // Camera
    function PerspectiveCamera(fov, aspect, near, far) {
        Object3D.call(this);
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.projectionMatrix = new Matrix4();
        this.matrixWorldInverse = new Matrix4();
        this.lookDirection = null;
    }
    
    PerspectiveCamera.prototype = Object.create(Object3D.prototype);
    PerspectiveCamera.prototype.constructor = PerspectiveCamera;
    
    PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        this.lookDirection = { 
            x: x - this.position.x, 
            y: y - this.position.y, 
            z: z - this.position.z 
        };
    };
    
    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Update projection matrix - stub
    };
    
    // WebGL Renderer (with 2D fallback)
    function WebGLRenderer(parameters = {}) {
        this.canvas = parameters.canvas || document.createElement('canvas');
        this.context = null;
        this.shadowMap = { enabled: false, type: null };
        this.fog = false;
        this.clearColor = { r: 0, g: 0, b: 0 };
        
        // Use 2D context for pseudo-3D rendering
        this.context = this.canvas.getContext('2d');
        this.is2D = true;
        
        console.log('WebGLRenderer initialized with 2D fallback');
    }
    
    WebGLRenderer.prototype.setSize = function(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
    };
    
    WebGLRenderer.prototype.setPixelRatio = function(ratio) {
        // Pixel ratio - stub
    };
    
    WebGLRenderer.prototype.setClearColor = function(color) {
        this.clearColor = {
            r: (color >> 16) & 255,
            g: (color >> 8) & 255,
            b: color & 255
        };
    };
    
    WebGLRenderer.prototype.render = function(scene, camera) {
        if (!this.context) return;
        this.render2D(scene, camera);
    };
    
    WebGLRenderer.prototype.render2D = function(scene, camera) {
        const ctx = this.context;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        ctx.fillStyle = `rgb(${this.clearColor.r}, ${this.clearColor.g}, ${this.clearColor.b})`;
        ctx.fillRect(0, 0, width, height);
        
        // Simple 3D to 2D projection for pseudo-3D maze view
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 25;
        
        // Camera position and direction
        const camX = camera.position.x;
        const camZ = camera.position.z;
        const camY = camera.position.y;
        
        // Get camera look angle
        let lookAngle = 0;
        if (camera.lookDirection) {
            lookAngle = Math.atan2(camera.lookDirection.x, camera.lookDirection.z);
        }
        
        // Arrays to hold objects by distance for proper depth sorting
        const wallObjects = [];
        const floorObjects = [];
        const goalObjects = [];
        
        // Collect all renderable objects
        scene.traverse((object) => {
            if (object.geometry && object.material && object.visible) {
                const dx = object.position.x - camX;
                const dz = object.position.z - camZ;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                const objData = { object, distance, dx, dz };
                
                if (object.geometry.type === 'BoxGeometry') {
                    wallObjects.push(objData);
                } else if (object.geometry.type === 'PlaneGeometry') {
                    floorObjects.push(objData);
                } else if (object.geometry.type === 'CylinderGeometry') {
                    goalObjects.push(objData);
                }
            }
        });
        
        // Sort by distance (far to near for proper rendering)
        wallObjects.sort((a, b) => b.distance - a.distance);
        floorObjects.sort((a, b) => b.distance - a.distance);
        goalObjects.sort((a, b) => b.distance - a.distance);
        
        // Render floor first
        floorObjects.forEach(objData => {
            this.renderFloor(ctx, objData, camera, centerX, centerY, scale, lookAngle);
        });
        
        // Render walls
        wallObjects.forEach(objData => {
            this.renderWall(ctx, objData, camera, centerX, centerY, scale, lookAngle);
        });
        
        // Render goal objects last
        goalObjects.forEach(objData => {
            this.renderGoal(ctx, objData, camera, centerX, centerY, scale, lookAngle);
        });
        
        // Draw crosshair
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX - 10, centerY);
        ctx.lineTo(centerX + 10, centerY);
        ctx.moveTo(centerX, centerY - 10);
        ctx.lineTo(centerX, centerY + 10);
        ctx.stroke();
    };
    
    WebGLRenderer.prototype.renderWall = function(ctx, objData, camera, centerX, centerY, scale, lookAngle) {
        const { object: wall, distance, dx, dz } = objData;
        
        if (distance > 8 || distance < 0.1) return;
        
        // Calculate wall position relative to camera view
        const wallAngle = Math.atan2(dx, dz);
        const relativeAngle = wallAngle - lookAngle;
        
        // Normalize angle
        let normalizedAngle = relativeAngle;
        while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
        while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
        
        // Only render walls in front of camera
        if (Math.abs(normalizedAngle) > Math.PI / 2.2) return;
        
        // Project to screen
        const screenX = centerX + Math.sin(normalizedAngle) * scale * 25;
        const wallHeight = Math.max(15, (wall.geometry.height / Math.max(distance, 0.5)) * scale * 40);
        const wallWidth = Math.max(8, (wall.geometry.width / Math.max(distance, 0.5)) * scale * 20);
        
        // Get material color
        let color = '#888888';
        if (wall.material && typeof wall.material.color === 'number') {
            const c = wall.material.color;
            color = `rgb(${((c >> 16) & 255)}, ${((c >> 8) & 255)}, ${(c & 255)})`;
        }
        
        // Apply distance-based shading
        const shade = Math.max(0.3, 1 - distance / 8);
        const r = Math.floor(((wall.material.color >> 16) & 255) * shade);
        const g = Math.floor(((wall.material.color >> 8) & 255) * shade);
        const b = Math.floor((wall.material.color & 255) * shade);
        color = `rgb(${r}, ${g}, ${b})`;
        
        // Draw wall
        ctx.fillStyle = color;
        ctx.fillRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
        
        // Add border for better definition
        ctx.strokeStyle = '#aaaaaa';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
    };
    
    WebGLRenderer.prototype.renderFloor = function(ctx, objData, camera, centerX, centerY, scale, lookAngle) {
        const { object: floor, distance, dx, dz } = objData;
        
        if (distance > 6) return;
        
        const floorAngle = Math.atan2(dx, dz);
        const relativeAngle = floorAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 8;
        const screenY = centerY + distance * 12 + 60; // Floor appears lower
        
        if (screenY < centerY + 300 && screenY > centerY) {
            const floorSize = Math.max(3, 12 - distance);
            
            // Get floor color
            let color = '#333333';
            if (floor.material && typeof floor.material.color === 'number') {
                const c = floor.material.color;
                color = `rgb(${((c >> 16) & 255)}, ${((c >> 8) & 255)}, ${(c & 255)})`;
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(screenX - floorSize/2, screenY - floorSize/2, floorSize, floorSize);
        }
    };
    
    WebGLRenderer.prototype.renderGoal = function(ctx, objData, camera, centerX, centerY, scale, lookAngle) {
        const { object: goal, distance, dx, dz } = objData;
        
        if (distance > 10) return;
        
        const goalAngle = Math.atan2(dx, dz);
        const relativeAngle = goalAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 15;
        const goalSize = Math.max(5, (goal.geometry.radiusBottom / Math.max(distance, 0.1)) * scale * 15);
        
        // Get goal color
        let color = '#ff4444';
        if (goal.material && typeof goal.material.color === 'number') {
            const c = goal.material.color;
            color = `rgb(${((c >> 16) & 255)}, ${((c >> 8) & 255)}, ${(c & 255)})`;
        }
        
        // Draw goal as circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(screenX, centerY, goalSize, 0, 2 * Math.PI);
        ctx.fill();
        
        // Add glow effect
        ctx.strokeStyle = '#ff8888';
        ctx.lineWidth = 2;
        ctx.stroke();
    };
    
    // Geometry classes
    function BoxGeometry(width = 1, height = 1, depth = 1) {
        this.type = 'BoxGeometry';
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    
    function PlaneGeometry(width = 1, height = 1) {
        this.type = 'PlaneGeometry';
        this.width = width;
        this.height = height;
    }
    
    function CylinderGeometry(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8) {
        this.type = 'CylinderGeometry';
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radialSegments = radialSegments;
    }
    
    function RingGeometry(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8) {
        this.type = 'RingGeometry';
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.thetaSegments = thetaSegments;
    }
    
    function SphereGeometry(radius = 1, widthSegments = 8, heightSegments = 6) {
        this.type = 'SphereGeometry';
        this.radius = radius;
        this.widthSegments = widthSegments;
        this.heightSegments = heightSegments;
    }
    
    // Texture classes
    function CanvasTexture(canvas) {
        this.type = 'CanvasTexture';
        this.image = canvas;
        this.wrapS = 1000; // RepeatWrapping equivalent
        this.wrapT = 1000; // RepeatWrapping equivalent
        this.repeat = { 
            x: 1, 
            y: 1,
            set: function(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }
        };
    }
    
    CanvasTexture.prototype.set = function(x, y) {
        this.repeat.x = x;
        this.repeat.y = y;
        return this;
    };
    
    // Material classes
    function MeshLambertMaterial(parameters = {}) {
        this.type = 'MeshLambertMaterial';
        this.color = parameters.color !== undefined ? parameters.color : 0xffffff;
        this.emissive = parameters.emissive || 0x000000;
        this.transparent = parameters.transparent || false;
    }
    
    function MeshBasicMaterial(parameters = {}) {
        this.type = 'MeshBasicMaterial';
        this.color = parameters.color !== undefined ? parameters.color : 0xffffff;
        this.wireframe = parameters.wireframe || false;
    }
    
    function MeshPhongMaterial(parameters = {}) {
        this.type = 'MeshPhongMaterial';
        this.color = parameters.color !== undefined ? parameters.color : 0xffffff;
        this.emissive = parameters.emissive !== undefined ? parameters.emissive : 0x000000;
        this.shininess = parameters.shininess !== undefined ? parameters.shininess : 30;
        this.transparent = parameters.transparent || false;
        this.opacity = parameters.opacity !== undefined ? parameters.opacity : 1;
        this.map = parameters.map || null;
    }
    
    // Mesh
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.geometry = geometry;
        this.material = material;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Mesh.prototype = Object.create(Object3D.prototype);
    Mesh.prototype.constructor = Mesh;
    
    // Light classes (stubs for compatibility)
    function AmbientLight(color, intensity) {
        Object3D.call(this);
        this.type = 'AmbientLight';
        this.color = color;
        this.intensity = intensity;
    }
    AmbientLight.prototype = Object.create(Object3D.prototype);
    
    function SpotLight(color, intensity, distance, angle, decay) {
        Object3D.call(this);
        this.type = 'SpotLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
        this.angle = angle;
        this.decay = decay;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 1024, height: 1024 },
            camera: { near: 0.1, far: 20 }
        };
        this.target = new Object3D();
    }
    SpotLight.prototype = Object.create(Object3D.prototype);
    
    function DirectionalLight(color, intensity) {
        Object3D.call(this);
        this.type = 'DirectionalLight';
        this.color = color;
        this.intensity = intensity;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 2048, height: 2048 }
        };
    }
    DirectionalLight.prototype = Object.create(Object3D.prototype);
    
    function PointLight(color, intensity, distance) {
        Object3D.call(this);
        this.type = 'PointLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
    }
    PointLight.prototype = Object.create(Object3D.prototype);
    
    // Fog
    function Fog(color, near, far) {
        this.color = color;
        this.near = near;
        this.far = far;
    }
    
    // Constants
    const PCFSoftShadowMap = 'PCFSoftShadowMap';
    const RepeatWrapping = 1000;
    
    // Export THREE namespace
    window.THREE = {
        Scene: Scene,
        PerspectiveCamera: PerspectiveCamera,
        WebGLRenderer: WebGLRenderer,
        BoxGeometry: BoxGeometry,
        PlaneGeometry: PlaneGeometry,
        CylinderGeometry: CylinderGeometry,
        RingGeometry: RingGeometry,
        SphereGeometry: SphereGeometry,
        CanvasTexture: CanvasTexture,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        Mesh: Mesh,
        AmbientLight: AmbientLight,
        SpotLight: SpotLight,
        DirectionalLight: DirectionalLight,
        PointLight: PointLight,
        Fog: Fog,
        Vector3: Vector3,
        Matrix4: Matrix4,
        Object3D: Object3D,
        PCFSoftShadowMap: PCFSoftShadowMap,
        RepeatWrapping: RepeatWrapping
    };
    
    console.log('Clean Three.js implementation loaded successfully');
})();