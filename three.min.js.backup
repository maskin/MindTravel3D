// Complete Three.js-compatible implementation for 3D maze rendering
(function() {
    'use strict';
    
    // Global canvas context for 2D fallback rendering
    let globalCanvas = null;
    let globalCtx = null;
    
    // Basic 3D math utilities
    function Vector3(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    Vector3.prototype.set = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    
    Vector3.prototype.copy = function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    
    // Object3D base class
    function Object3D() {
        this.position = new Vector3();
        this.rotation = new Vector3();
        this.scale = new Vector3(1, 1, 1);
        this.children = [];
        this.parent = null;
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Object3D.prototype.add = function(object) {
        this.children.push(object);
        object.parent = this;
    };
    
    Object3D.prototype.remove = function(object) {
        const index = this.children.indexOf(object);
        if (index > -1) {
            this.children.splice(index, 1);
            object.parent = null;
        }
    };
    
    // Scene class
    function Scene() {
        Object3D.call(this);
        this.fog = null;
        this.background = null;
    }
    Scene.prototype = Object.create(Object3D.prototype);
    Scene.prototype.constructor = Scene;
    
    // Camera class
    function PerspectiveCamera(fov = 50, aspect = 1, near = 0.1, far = 2000) {
        Object3D.call(this);
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.zoom = 1;
    }
    PerspectiveCamera.prototype = Object.create(Object3D.prototype);
    PerspectiveCamera.prototype.constructor = PerspectiveCamera;
    
    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Update projection matrix (placeholder)
    };
    
    // Material classes
    function Material() {
        this.color = { r: 1, g: 1, b: 1 };
        this.transparent = false;
        this.opacity = 1;
        this.wireframe = false;
    }
    
    function MeshLambertMaterial(params = {}) {
        Material.call(this);
        if (params.color !== undefined) {
            this.color = this.parseColor(params.color);
        }
        if (params.transparent !== undefined) {
            this.transparent = params.transparent;
        }
        if (params.wireframe !== undefined) {
            this.wireframe = params.wireframe;
        }
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    
    MeshLambertMaterial.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 1, g: 1, b: 1 };
    };
    
    // Geometry classes
    function Geometry() {
        this.vertices = [];
        this.faces = [];
    }
    
    function BoxGeometry(width = 1, height = 1, depth = 1) {
        Geometry.call(this);
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.generateBox();
    }
    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;
    
    BoxGeometry.prototype.generateBox = function() {
        const w = this.width / 2;
        const h = this.height / 2;
        const d = this.depth / 2;
        
        // Box vertices
        this.vertices = [
            [-w, -h, -d], [w, -h, -d], [w, h, -d], [-w, h, -d],  // front
            [-w, -h, d], [w, -h, d], [w, h, d], [-w, h, d]       // back
        ];
        
        // Box faces (simplified)
        this.faces = [
            [0, 1, 2, 3], // front
            [4, 7, 6, 5], // back
            [0, 4, 5, 1], // bottom
            [2, 6, 7, 3], // top
            [0, 3, 7, 4], // left
            [1, 5, 6, 2]  // right
        ];
    };
    
    function PlaneGeometry(width = 1, height = 1) {
        Geometry.call(this);
        this.width = width;
        this.height = height;
        this.generatePlane();
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    
    PlaneGeometry.prototype.generatePlane = function() {
        const w = this.width / 2;
        const h = this.height / 2;
        
        this.vertices = [
            [-w, 0, -h], [w, 0, -h], [w, 0, h], [-w, 0, h]
        ];
        
        this.faces = [[0, 1, 2, 3]];
    };
    
    function CylinderGeometry(radiusTop = 1, radiusBottom = 1, height = 1) {
        Geometry.call(this);
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.generateCylinder();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    
    CylinderGeometry.prototype.generateCylinder = function() {
        // Simplified cylinder as octagon
        const segments = 8;
        const h = this.height / 2;
        const r = this.radiusBottom;
        
        this.vertices = [];
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            this.vertices.push([x, -h, z], [x, h, z]);
        }
        
        this.faces = [];
        for (let i = 0; i < segments; i++) {
            const next = (i + 1) % segments;
            this.faces.push([i*2, next*2, next*2+1, i*2+1]);
        }
    };
    
    // Mesh class
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.geometry = geometry;
        this.material = material;
    }
    Mesh.prototype = Object.create(Object3D.prototype);
    Mesh.prototype.constructor = Mesh;
    
    // Light classes
    function Light(color = 0xffffff, intensity = 1) {
        Object3D.call(this);
        this.color = this.parseColor(color);
        this.intensity = intensity;
    }
    Light.prototype = Object.create(Object3D.prototype);
    Light.prototype.constructor = Light;
    
    Light.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 1, g: 1, b: 1 };
    };
    
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
    }
    AmbientLight.prototype = Object.create(Light.prototype);
    AmbientLight.prototype.constructor = AmbientLight;
    
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.target = new Object3D();
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: { near: 0.5, far: 500 }
        };
    }
    DirectionalLight.prototype = Object.create(Light.prototype);
    DirectionalLight.prototype.constructor = DirectionalLight;
    
    function SpotLight(color, intensity, distance, angle, penumbra) {
        Light.call(this, color, intensity);
        this.distance = distance || 0;
        this.angle = angle || Math.PI / 3;
        this.penumbra = penumbra || 0;
        this.target = new Object3D();
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 512, height: 512 },
            camera: { near: 0.5, far: 500 }
        };
    }
    SpotLight.prototype = Object.create(Light.prototype);
    SpotLight.prototype.constructor = SpotLight;
    
    function PointLight(color, intensity, distance) {
        Light.call(this, color, intensity);
        this.distance = distance || 0;
    }
    PointLight.prototype = Object.create(Light.prototype);
    PointLight.prototype.constructor = PointLight;
    
    // Fog class
    function Fog(color, near, far) {
        this.color = this.parseColor(color);
        this.near = near || 1;
        this.far = far || 1000;
    }
    
    Fog.prototype.parseColor = function(color) {
        if (typeof color === 'number') {
            return {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
        return { r: 0, g: 0, b: 0 };
    };
    
    // WebGL Renderer with 2D Canvas fallback
    function WebGLRenderer(params = {}) {
        this.domElement = params.canvas || document.createElement('canvas');
        this.context = null;
        this.shadowMap = { enabled: false, type: 'PCFSoftShadowMap' };
        this.fog = false;
        this.clearColor = { r: 0, g: 0, b: 0 };
        
        // Initialize 2D context for fallback rendering
        if (this.domElement) {
            globalCanvas = this.domElement;
            globalCtx = this.domElement.getContext('2d');
            this.context = globalCtx;
        }
        
        console.log('WebGLRenderer initialized with 2D fallback');
    }
    
    WebGLRenderer.prototype.setSize = function(width, height) {
        if (this.domElement) {
            this.domElement.width = width;
            this.domElement.height = height;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
        }
    };
    
    WebGLRenderer.prototype.setPixelRatio = function(ratio) {
        // Placeholder
    };
    
    WebGLRenderer.prototype.setClearColor = function(color) {
        if (typeof color === 'number') {
            this.clearColor = {
                r: ((color >> 16) & 255) / 255,
                g: ((color >> 8) & 255) / 255,
                b: (color & 255) / 255
            };
        }
    };
    
    WebGLRenderer.prototype.render = function(scene, camera) {
        if (!this.context || !globalCanvas) return;
        
        const ctx = this.context;
        const canvas = globalCanvas;
        
        // Clear canvas with black background
        ctx.fillStyle = `rgb(${this.clearColor.r * 255}, ${this.clearColor.g * 255}, ${this.clearColor.b * 255})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Simple 3D to 2D projection rendering
        this.renderScene(scene, camera, ctx, canvas);
    };
    
    WebGLRenderer.prototype.renderScene = function(scene, camera, ctx, canvas) {
        const cameraX = camera.position.x;
        const cameraZ = camera.position.z;
        const cameraY = camera.position.y;
        const cameraRotY = camera.rotation.y;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 100; // Projection scale
        
        let wallCount = 0;
        let floorCount = 0;
        
        // Render all objects in scene
        this.traverseAndRender(scene, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, {wallCount: 0, floorCount: 0});
        
        // Draw debug info
        ctx.fillStyle = '#00ff00';
        ctx.font = '14px Arial';
        ctx.fillText(`Camera: ${cameraX.toFixed(1)}, ${cameraY.toFixed(1)}, ${cameraZ.toFixed(1)}`, 10, canvas.height - 60);
        ctx.fillText(`Canvas: ${canvas.width}x${canvas.height}`, 10, canvas.height - 40);
        ctx.fillText('RENDERER ACTIVE', 10, canvas.height - 20);
    };
    
    WebGLRenderer.prototype.traverseAndRender = function(object, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters) {
        if (!object.visible) return;
        
        if (object.geometry && object.material) {
            this.renderMesh(object, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters);
        }
        
        // Render children
        for (let child of object.children) {
            this.traverseAndRender(child, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters);
        }
    };
    
    WebGLRenderer.prototype.renderMesh = function(mesh, camera, ctx, centerX, centerY, scale, cameraX, cameraY, cameraZ, cameraRotY, counters) {
        const objX = mesh.position.x;
        const objY = mesh.position.y;
        const objZ = mesh.position.z;
        
        // Simple distance culling
        const dx = objX - cameraX;
        const dz = objZ - cameraZ;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 15) return; // Don't render distant objects
        
        // Rotate relative to camera
        const cos = Math.cos(-cameraRotY);
        const sin = Math.sin(-cameraRotY);
        const rotX = dx * cos - dz * sin;
        const rotZ = dx * sin + dz * cos;
        
        // Skip objects behind camera
        if (rotZ <= 0.1) return;
        
        // Project to screen
        const screenX = centerX + (rotX / rotZ) * scale;
        const screenY = centerY - ((objY - cameraY) / rotZ) * scale;
        const size = scale / rotZ;
        
        // Skip objects outside screen
        if (screenX < -100 || screenX > centerX * 2 + 100 || 
            screenY < -100 || screenY > centerY * 2 + 100) return;
        
        // Determine color from material
        let color = '#888888'; // Default gray
        if (mesh.material && mesh.material.color) {
            const c = mesh.material.color;
            color = `rgb(${Math.floor(c.r * 255)}, ${Math.floor(c.g * 255)}, ${Math.floor(c.b * 255)})`;
        }
        
        // Render based on geometry type
        if (mesh.geometry.constructor.name === 'BoxGeometry') {
            // Render as rectangle (wall)
            const width = size * mesh.geometry.width;
            const height = size * mesh.geometry.height;
            
            ctx.fillStyle = color;
            ctx.fillRect(screenX - width/2, screenY - height/2, width, height);
            
            // Add wireframe for visibility
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(screenX - width/2, screenY - height/2, width, height);
            
            counters.wallCount++;
            
        } else if (mesh.geometry.constructor.name === 'PlaneGeometry') {
            // Render as small rectangle (floor)
            const tileSize = size * 0.8;
            
            ctx.fillStyle = color;
            ctx.fillRect(screenX - tileSize/2, screenY - tileSize/2, tileSize, tileSize);
            
            counters.floorCount++;
            
        } else if (mesh.geometry.constructor.name === 'CylinderGeometry') {
            // Render as circle (goal)
            const radius = size * mesh.geometry.radiusBottom;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Glow effect for goal
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(screenX, screenY, radius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    };
    
    // Constants
    const PCFSoftShadowMap = 'PCFSoftShadowMap';
    
    // Export the THREE object
    window.THREE = {
        Scene: Scene,
        PerspectiveCamera: PerspectiveCamera,
        WebGLRenderer: WebGLRenderer,
        BoxGeometry: BoxGeometry,
        PlaneGeometry: PlaneGeometry,
        CylinderGeometry: CylinderGeometry,
        MeshLambertMaterial: MeshLambertMaterial,
        Mesh: Mesh,
        AmbientLight: AmbientLight,
        DirectionalLight: DirectionalLight,
        SpotLight: SpotLight,
        PointLight: PointLight,
        Fog: Fog,
        Vector3: Vector3,
        Object3D: Object3D,
        PCFSoftShadowMap: PCFSoftShadowMap
    };
    
    console.log('THREE.js compatible library loaded with 2D fallback renderer');
})();
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.projectionMatrix = new Matrix4();
        this.matrixWorldInverse = new Matrix4();
    }
    
    PerspectiveCamera.prototype = Object.create(Object3D.prototype);
    PerspectiveCamera.prototype.constructor = PerspectiveCamera;
    
    PerspectiveCamera.prototype.lookAt = function(x, y, z) {
        // Simple look-at implementation for rendering
        this.lookDirection = { x: x - this.position.x, y: y - this.position.y, z: z - this.position.z };
    };
    
    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        // Update projection matrix
    };
    
    // WebGL Renderer
    function WebGLRenderer(parameters = {}) {
        this.canvas = parameters.canvas || document.createElement('canvas');
        this.context = null;
        this.shadowMap = { enabled: false, type: null };
        this.fog = false;
        
        // Force 2D fallback for now as our WebGL implementation is incomplete
        this.context = this.canvas.getContext('2d');
        this.is2D = true;
        
        console.log('WebGLRenderer initialized with 2D fallback');
        console.log('Canvas element:', this.canvas);
        console.log('Canvas dimensions:', this.canvas.width, 'x', this.canvas.height);
        console.log('Canvas parent:', this.canvas.parentElement);
        
        this.clearColor = { r: 0, g: 0, b: 0 };
        
        // Add immediate test rendering
        if (this.context) {
            this.context.fillStyle = '#ff0000';
            this.context.fillRect(0, 0, 100, 100);
            console.log('Test red square drawn to canvas');
        }
    }
    
    WebGLRenderer.prototype.setSize = function(width, height) {
        console.log('setSize called with:', width, 'x', height);
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        console.log('Canvas size set to:', this.canvas.width, 'x', this.canvas.height);
    };
    
    WebGLRenderer.prototype.setPixelRatio = function(ratio) {
        // Set pixel ratio
    };
    
    WebGLRenderer.prototype.setClearColor = function(color) {
        this.clearColor = {
            r: (color >> 16) & 255,
            g: (color >> 8) & 255,
            b: color & 255
        };
    };
    
    WebGLRenderer.prototype.render = function(scene, camera) {
        if (!this.context) return;
        
        console.log('Renderer.render called - is2D:', this.is2D, 'context type:', this.is2D ? '2D' : 'WebGL');
        
        if (this.is2D) {
            this.render2D(scene, camera);
        } else {
            this.renderWebGL(scene, camera);
        }
    };
    
    WebGLRenderer.prototype.render2D = function(scene, camera) {
        const ctx = this.context;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        console.log('render2D: Canvas context:', ctx);
        console.log('render2D: Canvas dimensions:', width, 'x', height);
        
        // Clear canvas with debug background - use bright color to ensure visibility
        ctx.fillStyle = '#333333';
        ctx.fillRect(0, 0, width, height);
        
        // Draw a test rectangle that should definitely be visible
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(100, 100, 200, 200);
        console.log('Test red rectangle drawn');
        
        // Add visible background pattern to help debug canvas visibility
        ctx.fillStyle = '#666666';
        for (let i = 0; i < width; i += 50) {
            for (let j = 0; j < height; j += 50) {
                if ((Math.floor(i/50) + Math.floor(j/50)) % 2 === 0) {
                    ctx.fillRect(i, j, 50, 50);
                }
            }
        }
        console.log('Background pattern drawn');
        
        // Simple 3D to 2D projection for maze visualization
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 20; // Scale factor for projection
        
        // Camera position and direction
        const camX = camera.position.x;
        const camZ = camera.position.z;
        const camY = camera.position.y;
        
        // Get camera direction
        let lookAngle = 0;
        if (camera.lookDirection) {
            lookAngle = Math.atan2(camera.lookDirection.x, camera.lookDirection.z);
        }
        
        console.log('Rendering frame - Camera:', { x: camX, y: camY, z: camZ }, 'Look angle:', lookAngle);
        
        // Count objects to render
        let wallCount = 0;
        let floorCount = 0;
        
        // Render maze walls and floor
        scene.traverse((object) => {
            if (object.geometry && object.material) {
                if (object.geometry.type === 'BoxGeometry') {
                    // Render wall as a rectangle in 3D perspective
                    this.renderBox(ctx, object, camera, centerX, centerY, scale, lookAngle);
                    wallCount++;
                } else if (object.geometry.type === 'PlaneGeometry') {
                    // Render floor
                    this.renderFloor(ctx, object, camera, centerX, centerY, scale, lookAngle);
                    floorCount++;
                } else if (object.geometry.type === 'CylinderGeometry') {
                    // Render goal
                    this.renderCylinder(ctx, object, camera, centerX, centerY, scale, lookAngle);
                }
            }
        });
        
        console.log('Rendered objects - Walls:', wallCount, 'Floor:', floorCount);
        
        // Add more prominent debug info
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 16px Arial';
        ctx.fillText(`MAZE RENDERER ACTIVE`, 10, 30);
        ctx.fillStyle = '#ffff00';
        ctx.font = '14px Arial';
        ctx.fillText(`Walls: ${wallCount}, Floor: ${floorCount}`, 10, height - 60);
        ctx.fillText(`Camera: ${camX.toFixed(1)}, ${camZ.toFixed(1)}, ${camY.toFixed(1)}`, 10, height - 40);
        ctx.fillText(`Canvas: ${width}x${height}`, 10, height - 20);
        
        // Add frame counter for animation verification
        if (!this.frameCounter) this.frameCounter = 0;
        this.frameCounter++;
        ctx.fillStyle = '#ff00ff';
        ctx.fillText(`Frame: ${this.frameCounter}`, 10, 50);
        
        // Draw crosshair - make it more visible
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#000000';
        ctx.shadowBlur = 2;
        
        // Draw crosshair
        ctx.beginPath();
        ctx.moveTo(centerX - 15, centerY);
        ctx.lineTo(centerX + 15, centerY);
        ctx.moveTo(centerX, centerY - 15);
        ctx.lineTo(centerX, centerY + 15);
        ctx.stroke();
        
        // Reset shadow
        ctx.shadowBlur = 0;
    };
    
    WebGLRenderer.prototype.renderBox = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Simple 3D wall rendering
        const wall = object;
        const dx = wall.position.x - camera.position.x;
        const dz = wall.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 8) return; // Don't render distant walls
        if (distance < 0.1) return; // Don't render walls too close
        
        // Calculate wall position relative to camera view
        const wallAngle = Math.atan2(dx, dz);
        const relativeAngle = wallAngle - lookAngle;
        
        // Normalize angle
        let normalizedAngle = relativeAngle;
        while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
        while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
        
        // Only render walls in front of camera (wider field of view)
        if (Math.abs(normalizedAngle) > Math.PI / 1.5) return;
        
        // Project to screen with better scaling
        const screenX = centerX + Math.sin(normalizedAngle) * scale * 20;
        const wallHeight = Math.max(10, (3 / Math.max(distance, 0.5)) * scale * 30);
        const wallWidth = Math.max(5, (1 / Math.max(distance, 0.5)) * scale * 15);
        
        // Get material color
        let color = '#888888';
        if (wall.material && wall.material.color !== undefined) {
            const c = wall.material.color;
            color = `rgb(${((c >> 16) & 255)}, ${((c >> 8) & 255)}, ${(c & 255)})`;
        }
        
        // Draw wall with better visibility
        ctx.fillStyle = color;
        ctx.fillRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
        
        // Add border for better visibility
        ctx.strokeStyle = '#aaaaaa';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
        
        // Add some shading based on distance
        const shade = Math.max(0.2, 1 - distance / 8);
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - shade})`;
        ctx.fillRect(
            screenX - wallWidth / 2,
            centerY - wallHeight / 2,
            wallWidth,
            wallHeight
        );
    };
    
    WebGLRenderer.prototype.renderFloor = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Simple floor grid rendering
        const floor = object;
        const dx = floor.position.x - camera.position.x;
        const dz = floor.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 6) return;
        
        // Draw floor tile
        const floorAngle = Math.atan2(dx, dz);
        const relativeAngle = floorAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 5;
        const screenY = centerY + distance * 8 + 50; // Floor appears lower
        
        if (screenY < centerY + 250 && screenY > centerY) { // Only render visible floor
            const floorSize = Math.max(2, 8 - distance);
            ctx.fillStyle = '#333333';
            ctx.fillRect(screenX - floorSize/2, screenY - floorSize/2, floorSize, floorSize);
        }
    };
    
    WebGLRenderer.prototype.renderCylinder = function(ctx, object, camera, centerX, centerY, scale, lookAngle) {
        // Render goal cylinder
        const goal = object;
        const dx = goal.position.x - camera.position.x;
        const dz = goal.position.z - camera.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 10) return;
        
        const goalAngle = Math.atan2(dx, dz);
        const relativeAngle = goalAngle - lookAngle;
        
        const screenX = centerX + Math.sin(relativeAngle) * scale * 10;
        const goalSize = (1 / Math.max(distance, 0.1)) * scale * 8;
        
        // Draw goal as red circle
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(screenX, centerY, goalSize, 0, 2 * Math.PI);
        ctx.fill();
        
        // Add glow effect
        ctx.strokeStyle = '#ff8888';
        ctx.lineWidth = 2;
        ctx.stroke();
    };
    
    WebGLRenderer.prototype.renderWebGL = function(scene, camera) {
        // Basic WebGL implementation would go here
        // For now, fall back to basic clearing
        const gl = this.context;
        gl.clearColor(this.clearColor.r / 255, this.clearColor.g / 255, this.clearColor.b / 255, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    
    // Geometry classes
    function BoxGeometry(width, height, depth) {
        this.type = 'BoxGeometry';
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    
    function PlaneGeometry(width, height) {
        this.type = 'PlaneGeometry';
        this.width = width;
        this.height = height;
    }
    
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments) {
        this.type = 'CylinderGeometry';
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radialSegments = radialSegments;
    }
    
    // Material classes
    function MeshLambertMaterial(parameters = {}) {
        this.type = 'MeshLambertMaterial';
        this.color = parameters.color || 0xffffff;
        this.emissive = parameters.emissive || 0x000000;
        this.transparent = parameters.transparent || false;
    }
    
    function MeshBasicMaterial(parameters = {}) {
        this.type = 'MeshBasicMaterial';
        this.color = parameters.color || 0xffffff;
        this.wireframe = parameters.wireframe || false;
    }
    
    // Mesh
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.geometry = geometry;
        this.material = material;
        this.castShadow = false;
        this.receiveShadow = false;
    }
    
    Mesh.prototype = Object.create(Object3D.prototype);
    Mesh.prototype.constructor = Mesh;
    
    // Lights
    function AmbientLight(color, intensity) {
        Object3D.call(this);
        this.type = 'AmbientLight';
        this.color = color;
        this.intensity = intensity;
    }
    
    AmbientLight.prototype = Object.create(Object3D.prototype);
    
    function SpotLight(color, intensity, distance, angle, decay) {
        Object3D.call(this);
        this.type = 'SpotLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
        this.angle = angle;
        this.decay = decay;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 1024, height: 1024 },
            camera: { near: 0.1, far: 20 }
        };
        this.target = new Object3D();
    }
    
    SpotLight.prototype = Object.create(Object3D.prototype);
    
    function DirectionalLight(color, intensity) {
        Object3D.call(this);
        this.type = 'DirectionalLight';
        this.color = color;
        this.intensity = intensity;
        this.castShadow = false;
        this.shadow = {
            mapSize: { width: 2048, height: 2048 }
        };
    }
    
    DirectionalLight.prototype = Object.create(Object3D.prototype);
    
    function PointLight(color, intensity, distance) {
        Object3D.call(this);
        this.type = 'PointLight';
        this.color = color;
        this.intensity = intensity;
        this.distance = distance;
    }
    
    PointLight.prototype = Object.create(Object3D.prototype);
    
    // Fog
    function Fog(color, near, far) {
        this.color = color;
        this.near = near;
        this.far = far;
    }
    
    // Constants
    const PCFSoftShadowMap = 'PCFSoftShadowMap';
    
    // Export THREE namespace
    window.THREE = {
        Scene: Scene,
        PerspectiveCamera: PerspectiveCamera,
        WebGLRenderer: WebGLRenderer,
        BoxGeometry: BoxGeometry,
        PlaneGeometry: PlaneGeometry,
        CylinderGeometry: CylinderGeometry,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        Mesh: Mesh,
        AmbientLight: AmbientLight,
        SpotLight: SpotLight,
        DirectionalLight: DirectionalLight,
        PointLight: PointLight,
        Fog: Fog,
        Vector3: Vector3,
        Matrix4: Matrix4,
        Object3D: Object3D,
        PCFSoftShadowMap: PCFSoftShadowMap
    };
    
    console.log('Functional Three.js implementation loaded');
})();